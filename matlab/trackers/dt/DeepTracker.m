classdef DeepTracker < LabelTracker
  
  properties (Dependent)
    algorithmName;
    algorithmNamePretty
    sPrm % new-style DT params
  end
  properties (Constant,Hidden)
    SAVEPROPS = {'sPrmAll' 'containerBindPaths' ...
      'trnNetType' 'trnLastDMC' 'movIdx2trkfile' 'hideViz' ...
      'jrcgpuqueue' 'jrcnslots'}; 
     
    pretrained_weights_urls = {...
      'http://download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC.tar.gz'
      'http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz'...
      };
    pretrained_weights_files_pat_lnx = {...
      '%s/pretrained/resnet_v2_fp32_savedmodel_NHWC/1538687283/variables/variables.index'... % fill in deepnetroot
      '%s/pretrained/resnet_v1_50.ckpt'... 
      };
    pretrained_download_script_py = '%s/download_pretrained.py'; % fill in deepnetroot
    
    MDN_OCCLUDED_THRESH = 0.5;
  end
  properties
    jrcgpuqueue = 'gpu_any';
    jrcnslots = 1;
    jrcnslotstrack = 1; % transient
  end
  properties
    dryRunOnly % transient, scalar logical. If true, stripped lbl, cmds 
      % are generated for DL, but actual DL train/track are not spawned
    skip_dlgs % MK: Skip save/delete dialogs for testing.
  end
  properties
    containerBindPaths % cellstr of bind paths for sing/docker
      % Will be used if it is nonempty; otherwise an attempt will be made 
      % to autogenerate the required bind/mount paths.
  end
  properties (Dependent)
    condaEnv; % = 'APT'; % name of conda environment
  end
      
    %% train
    
    % - The trained model lives in the fileSys in <cacheDir>/<proj>view%d/trnName.
    % - Right now you can only have one train running at a time.
    
    % chars, currently autogenerated.
    % - When you retrain, you make a new trnName, every time.
    % - In the cacheDir, a subfolder is created .../<trnName>. This
    % subfolder holds the entire state for your trained model.
    % - Within the subfolder, multiple stripped lbls may exist:
    %   .../<trnName>/<trnNameLbl1>, .../<trnName>/<trnNameLbl2>, ...
    %   representing restarts-with-data-augmentation. The current stripped
    %   lbl (ie typically the one used in the most recent train) is
    %   identified by .trnNameLbl.
    % - As far as DeepTracker.m is concerned, the only output/artifacts 
    % generated by training are these two identifiers.
    % FUTURE TODO: what happens when user alters cacheDir?
      
  properties (SetAccess=private)
    trnNetType = DLNetType.mdn; % scalar DLNetType
  end
  properties (Dependent)
    trnName
    trnNameLbl
    filesep
  end
  properties
    % Notes on trnLastDMC.
    %
    % This prop represents the "most recently trained model" for this
    % tracker obj. In many/most workflows the APT UI and backend share a
    % local filesystem and this most recent model lives on this local 
    % filesystem.
    %
    % In some cases, training and tracking occurs remotely relative to the 
    % APT frontend. In this case, there are two relevant filesystems: the 
    % local one available to APT, and the remote one available to the 
    % backend. At various points in a training/tracking workflow, trained 
    % models will exist on BOTH filesystems:
    %
    % * At project load, an existing model might be untarred locally, or 
    % there might be no existing model for a new project.
    % * At train time, a new model model is generated remotely.
    % * At retrain-, augmentedtrain-, or track-time, the local model will 
    % first be uploaded to the remote filesys if necessary.
    % * At project save time, remote models will be downloaded locally
    % before tarring into the project.
    %
    % With regards to this issue, our invariant for .trnLastDMC is that 
    %
    %   .trnLastDMC contains the most recently updated model for the 
    %   tracker, with the .reader property correctly indicating the 
    %   filesystem location of that model. This model is the one that
    %   should be used for inference, saved to projects, etc. Let's call it
    %   the "latest model" (for this tracker).
    %
    % * At project load, all .trnLastDMCs will point to the local
    % filesystem/cache.
    % * When a remote fresh train is spawned, .trnLastDMC is immediately 
    % set to the remote location. Even if the train fails or is killed
    % early, whatever is there remotely is still the latest model.
    % * If a remote track is spawned and the latest model is local, it is
    % uploaded first so the track can occur. The moment this upload 
    % completes, the latest model is moved/set to the remote location.
    % * For now we punt on retrains/augmentedtrains. These pose an issue in
    % that depending on the result of the remote train, the latest model
    % may remain local (eg if the remote train fails, maybe). Maybe the 
    % rule is as simple as "the remote model becomes the latest model if 
    % training completes successfully" but I am not sure. Skip it for now.
    % * At project save-time, the latest model (whereever it may be) is
    % tarred into the project. If the latest model is remote, then it is
    % downloaded first. This download does not update the latest model
    % pointer as the user may continue using the remote/latest model for 
    % tracking.
    %
    % So for now, for the AWS backend, the latest model may start locally, 
    % but once a train or track operation occurs, it will be remote from
    % that point onwards. Conceptually a user could switch backends to
    % local and that would allow the movie to "move back down" but we're
    % not going to worry about that for now.
    trnLastDMC % [nview] Last DeepModelChainOnDisk(s), set during training
    trnTblP % transient, unmanaged. Training rows for last retrain
    
    trnSplitLastDMC % [nsplit] Last DMCs, one per split; transient/unmanaged
    
    bgTrnMonitor % BgTrainMonitor obj
    bgTrnMonBGWorkerObj % bgTrainWorkerObj for last/current train
    bgTrnMonitorVizClass % class of trainMonitorViz object to use to monitor training
        
    %% track

    % - Right now you can only have one track running at a time.
    
    trkDockerCPU = false; % transient, scalar logical. If true and using Docker backend, use CPU for tracking
    
    trkGenHeatMaps % transient, scalar logical. If true, include --hmaps opt
      % to generate heatmaps on disk
      
    trkGTtrkTbl % transient, table of gt results
   
    trkSysInfo % [nview] transient, unmanaged. struct array of info used 
    % for current or most recent tracking codegen/system call. currently 
    % only used for debugging, printing logfiles etc.
    
    bgTrkMonitor % BgTrackMonitor obj
    bgTrkMonBGWorkerObj % bgTrackWorkerObj for last/current rack
    bgTrkMonitorVizClass % class of trackMonitorViz object to use to monitor tracking
    
    % trackres: tracking results DB is in filesys
    movIdx2trkfile % map from MovieIndex.id to [ntrkxnview] cellstrs of trkfile fullpaths
  end
  
  properties (SetObservable)
    
    trackerInfo = [];% information about the current tracker being used for tracking
    
  end
  properties (Dependent)
    bgTrnIsRunning
    bgTrkIsRunning 
  end

  properties
    % track curr res -- in-mem tracking results for current mov    
    trkP   % [npt x 2 x nfrm x ntgt] tracking results for current mov
    trkPTS % [npt x nfrm x ntgt] timestamp for trkP*
    
    trkAux % [npt x nfrm x ntgt x naux] auxiliary per-pt results eg confidences
    trkAuxLbl % [naux] labels for 4th dim of trxAux
              % naux given in DLNetType
%     trkPMD % [NTst <ncols>] table. cols: .mov, .frm, .iTgt
%            % .mov has class movieIndex 
  end
  properties (Dependent)
    nPts % number of label points     
    nview 
    %hasTrained
  end
  
  properties
    trkVizer % scalar TrackingVisualizer
  end
  
  events
    % Thrown when new tracking results are loaded for the current lObj
    % movie
    newTrackingResults 
    
    trainStart
    trainEnd
    trackStart
    trackEnd    
  end
  
  methods
    function v = get.algorithmName(obj)
      v = char(obj.trnNetType);
    end
    function v = get.algorithmNamePretty(obj)
      v = ['Deep Convolutional Network - ' obj.trnNetType.prettyString];
    end
    function v = get.condaEnv(obj)
      v = obj.lObj.trackDLBackEnd.condaEnv;
    end
    function v = get.trnName(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = {dmc.modelChainID};
        assert(all(strcmp(v{1},v)));
        v = v{1};
      end
    end
    function v = get.trnNameLbl(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = {dmc.trainID};
        assert(all(strcmp(v{1},v)));
        v = v{1};
      end
    end
    function v = get.filesep(obj)
      v = obj.lObj.trackDLBackEnd.filesep;
    end
    function v = get.nPts(obj)
      v = obj.lObj.nLabelPoints;
    end
    function v = get.nview(obj)
      v = obj.lObj.nview;
    end
    function v = get.bgTrnIsRunning(obj)
      btm = obj.bgTrnMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
    function v = get.bgTrkIsRunning(obj)
      btm = obj.bgTrkMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
  end
  
  methods
    function obj = DeepTracker(lObj,varargin)
      obj@LabelTracker(lObj);
      
      for i=1:2:numel(varargin)
        prop = varargin{i};
        val = varargin{i+1};
        obj.(prop) = val;
      end
      
      obj.bgTrnMonitor = [];
      obj.bgTrnMonitorVizClass = 'TrainMonitorViz';
      obj.bgTrkMonitor = [];
      obj.bgTrkMonitorVizClass = 'TrackMonitorViz';
      
      tvtagpfix = sprintf('dt_%s',obj.algorithmName);
      obj.trkVizer = TrackingVisualizerMT(lObj,tvtagpfix);
      obj.skip_dlgs = false;
    end
    function delete(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function initHook(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      obj.trackResInit();
      obj.trackCurrResInit();
      obj.vizInit();
      obj.updateTrackerInfo();
    end
  end
  
  %% Params
  methods (Static)
    
    function sPrmAll = massageParamsIfNecStc(net,sPrmAll,varargin)
      % net-specific parameter treatments
      %
      % net: DLNetType
      %
      % Openpose currently requires particular constraints between
      % parameters that are not required for other DL trackers. Current
      % treatment is
      % - lObj.trackParams continues to be "anything", ie user continues
      % to specify whatever they like in Tracking Parameters. (More
      % precisely, there may be constraints amongst parameters at this
      % level, but these constraints are common to all DL trackers.)
      % - When the universal params are to be set on a specific DL
      % tracker, we may mutate them to meet any DLnet-specific
      % constraints.
      % - So in normal "steady" usage, specific DeepTrackers may have
      % parameters that differ (typically v slightly) from the "main"
      % params. This may be noted in the trackerInfoString.
      
      [throwwarnings] = myparse(varargin,...
        'throwwarnings',true...
        );
      
      %net = obj.trnNetType;
      switch net
        case {DLNetType.openpose DLNetType.leap}
          dl_steps = sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps;
          save_step = sPrmAll.ROOT.DeepTrack.Saving.save_step;
          display_step = sPrmAll.ROOT.DeepTrack.Saving.display_step;
          
          if dl_steps < display_step
            dl_steps = display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be greater than or equal to the display step. Updating to %d DL steps.',...
                net.prettyString,dl_steps);
            end
          end
          
          if mod(dl_steps,display_step)~=0
            dl_steps = ceil(dl_steps/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be an even multiple of the display step. Increasing DL steps to %d.',...
                net.prettyString,dl_steps);
            end
          end
          
          if save_step < display_step
            save_step = display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be greater than or equal to display step. Updating the DL save step to %d.',...
                net.prettyString,save_step);
            end
          end
          
          if mod(save_step,display_step)~=0
            save_step = ceil(save_step/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be an even multiple of the display step. Increasing the DL save step to %d.',...
                net.prettyString,save_step);
            end
          end
          
          sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps = dl_steps;
          sPrmAll.ROOT.DeepTrack.Saving.save_step = save_step;
      
        otherwise
          % none
      end
    end
    
  end
  methods
    
    % AL 20190415. Note on DeepTrack.Saving.CacheDir
    % Currently nothing never refers to
    % DeepTrackerObj.sPrmAll.Saving.CacheDir. Instead, only lObj.DLCacheDir
    % and DeepTrackerObj.trnLastDMC(iview).rootDir are used. 
    %
    % - (re)train time: DeepTrackerObj uses lObj.DLCacheDir and sets 
    % .trnLastDMC(:).rootDir to this location.
    % - track time: currently we assert that lObj.DLCacheDir matches the
    % .rootDir of any local DMCs to be used
    
    function [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        didParamsChange(obj,sPrmAll) % obj const
      
      tfDiffEmptiness = xor(isempty(obj.sPrmAll),isempty(sPrmAll));
      tfCommonChanged = tfDiffEmptiness || ~APTParameters.isEqualTrackDLParams(obj.sPrmAll,sPrmAll);
      tfPreProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPreProcParams(obj.sPrmAll,sPrmAll);
      tfPostProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      
      sOldSpecific = obj.sPrm;
      netType = obj.trnNetType.prettyString;
      sNewSpecific = sPrmAll.ROOT.DeepTrack.(netType);
      tfSpecificChanged = ~isequaln(sOldSpecific,sNewSpecific);
    end
      
    function sPrmAll = massageParamsIfNec(obj,sPrmAll,varargin) % obj const
      net = obj.trnNetType;
      sPrmAll = DeepTracker.massageParamsIfNecStc(net,sPrmAll,varargin{:});
    end
      
    function setAllParams(obj,sPrmAll)
      sPrmAll = obj.massageParamsIfNec(sPrmAll);
      
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        obj.didParamsChange(sPrmAll);
      
      obj.sPrmAll = sPrmAll;
      
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged,
        obj.initHook();
      end
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        obj.updateTrackerInfo(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
    function tfPostProcChanged = setPostProcParams(obj,sPrmAll)
      tfPostProcChanged = ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      obj.sPrmAll.ROOT.PostProcess = sPrmAll.ROOT.PostProcess;
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        obj.updateTrackerInfo(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
      
    function v = get.sPrm(obj)
      if isempty(obj.sPrmAll),
        v = [];
      else
        netType = obj.trnNetType.prettyString;
        v = obj.sPrmAll.ROOT.DeepTrack.(netType);
      end
    end
    function sPrm = getParams(obj)
      sPrm = obj.sPrm;
    end
    function tc = getTrackerClassAugmented(obj)
      tc = {class(obj) 'trnNetType' obj.trnNetType};
    end
    function s = getSaveToken(obj)
      s = struct();
      props = obj.SAVEPROPS;
      for p=props(:)',p=p{1}; %#ok<FXSET>
        s.(p) = obj.(p);
      end
      if ~isempty(obj.trnLastDMC)
        obj.trnLastDMC = obj.trnLastDMC.copyAndDetach();
      end
    end
    function loadSaveToken(obj,s)
      s = DeepTracker.modernizeSaveToken(s);
      
      obj.initHook(); % maybe handled upstream
      flds = fieldnames(s);
      flds = setdiff(flds,'hideViz');
      for f=flds(:)',f=f{1}; %#ok<FXSET>
        obj.(f) = s.(f);
      end
      
      obj.dryRunOnly = false;
      
      obj.setHideViz(s.hideViz);
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  methods (Static)
    function s = modernizeSaveToken(s)
      % 20181215
      if isfield(s,'awsEc2')
        s = rmfield(s,'awsEc2');
      end
      if isfield(s,'backendType')
        s = rmfield(s,'backendType');
      end
      % 20181218
      if ~isfield(s,'containerBindPaths')
        s.containerBindPaths = cell(0,1);
      end 
      
      % 20190214
      % (Comment is basically C+P from CPRLabelTracker)
      % IMPORTANT philisophical note. We update/modernize .sPrmAll here,
      % but any changes should not invalidate previous trained trackers.
      % Parameters may be renamed, new parameters added, etc; but eg any 
      % new parameters added should be added with default values that 
      % effectively would have been previously used.

      assert(isfield(s,'sPrmAll') && ~isfield(s,'sPrm')); % taken care of in Labeler/lblModernize
      sPrmDflt = APTParameters.defaultParamsStructAll;      
      if ~isempty(s.sPrmAll)
        % Labeler/lblModernize may not have modernized s.sPrmAll
        s.sPrmAll = structoverlay(sPrmDflt,s.sPrmAll,...
          'dontWarnUnrecog',true); % to allow removal of obsolete params
      else
        % AL 20190713 leave s.sPrmAll empty for untrained trackers
        tfTrained = isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC);
        if tfTrained,
          warning('Apparent trained tracker with no parameters, setting trnLastDMC = []');
          s.trnLastDMC = [];
        end
        % assert(~tfTrained,'Apparent trained tracker with no parameters.');
        % s.sPrmAll = sPrmDflt;
        % Let's leave s.sPrmAll empty for now
      end
      
      % 20190405 
      % .trnName, .trnNameLbl removed as they dup .trnLastDMC
      if isfield(s,'trnName')
        s = rmfield(s,'trnName');
      end
      if isfield(s,'trnNameLbl')
        s = rmfield(s,'trnNameLbl');
      end
      % Add .reader to any .trnLastDMCs; assume local filesys
      if isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC) && ~isfield(s.trnLastDMC,'reader')
        rdrObj = DeepModelChainReaderLocal();
        [s.trnLastDMC.reader] = deal(rdrObj);
      end
      
      % 20190415
      % remove .movIdx2trkfile for now, with bundle-save we don't save
      % DeepTracker-stored tracking results
      if isfield(s,'movIdx2trkfile')
        s = rmfield(s,'movIdx2trkfile');
      end
      
      % 20190520: filesep needed for local windows
      if isfield(s,'trnLastDMC'),
        for i = 1:numel(s.trnLastDMC),
          if ~isempty(s.trnLastDMC(i)) && isempty(s.trnLastDMC(i).filesep),
            s.trnLastDMC.filesep = '/';
          end
        end
      end
    end
  end
  
  
  %% Train
  methods
    
    function train(obj)
      error('Incremental training is currently unsupported for Deep Learning.');
    end
    
    % Training timeline
    %
    % - Call to retrain. this creates a new jobname every time.
    % - stripped lbl written to <cacheDir>/<trnID>.lbl
    % - bg trn monitor started
    % - training spawned
    % - as log/intermediate results are written, loss viz in plot.
    % - you can start tracking at any time with the latest model by calling
    % track().
    % - FUTURE TODO you can't forcibly stop training for now.
    % - FUTURE TODO you can't choose to use a trained model before the last/final
    % - FUTURE TODO clean up old/unwanted trained models.
    % one if say it looked less overtrained or better.
    % - trained models will sit on disk; stripped lbl at 
    % <cache>/<trnName>.lbl, and models at <cache>/.../<trnName>
    
    % For Training, there are two processes
    % 1. The backend train itself. After this is spawned, this currently 
    % cannot be managed/killed from this class. If there is an issue the
    % actual compute needs to be manually killed.
    % 2. Background monitoring of the train. This can be reset with
    % bgTrnReset().
    
    function trnResInit(obj)
      obj.trnLastDMC = [];
      obj.bgTrnReset();
    end

    function bgTrnStart(obj,backEnd,dmcs,varargin)
      % fresh start new training monitor 
            
      [trainSplits] = myparse(varargin,...
        'trainSplits',false ...  % true for splits/xv
        );
      
      if ~isempty(obj.bgTrnMonitor)
        error('Training monitor exists. Call .bgTrnReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrnMonBGWorkerObj));

      if trainSplits
        nvw = numel(dmcs);
        trnStoppedCbkMeth = 'xvStoppedCbk';
        assert(backEnd.type==DLBackEnd.Bsub);
      else
        nvw = obj.lObj.nview;
        assert(numel(dmcs)==nvw);
        trnStoppedCbkMeth = 'trainStoppedCbk';
      end

      trnMonObj = BgTrainMonitor;
      addlistener(trnMonObj,'bgStart',@(s,e)obj.notify('trainStart'));
      addlistener(trnMonObj,'bgEnd',@(s,e) feval(trnStoppedCbkMeth,obj,s,e));

      switch backEnd.type
        case DLBackEnd.Bsub
          if trainSplits
            trnWrkObj = BgTrainSplitWorkerObjBsub(nvw,dmcs);            
          else
            trnWrkObj = BgTrainWorkerObjBsub(nvw,dmcs);
          end
        case DLBackEnd.Conda
          trnWrkObj = BgTrainWorkerObjConda(nvw,dmcs);
        case DLBackEnd.Docker
          trnWrkObj = BgTrainWorkerObjDocker(nvw,dmcs,backEnd);
        case DLBackEnd.AWS
          trnWrkObj = BgTrainWorkerObjAWS(nvw,dmcs,backEnd.awsec2);
        otherwise
          assert(false);
      end

      trnVizObj = feval(obj.bgTrnMonitorVizClass,nvw,obj,trnWrkObj,...
        backEnd.type,'trainSplits',trainSplits);
                
      trnMonObj.prepare(trnVizObj,trnWrkObj);
      trnMonObj.start();
      obj.bgTrnMonitor = trnMonObj;
      obj.bgTrnMonBGWorkerObj = trnWrkObj;
    end
    
    function bgTrnRestart(obj,bgTrnMonitorObj)
      % Mostly for debugging hanging monitors. "Kills" current bg training
      % monitor and restarts.
      
      fprintf(2,'Needs cleanup\n');
      
      if isempty(obj.bgTrnMonitor) || isempty(obj.bgTrnMonBGWorkerObj)
        error('Training monitor does not exist.');
      end
      
      workerObj = obj.bgTrnMonBGWorkerObj;
      fprintf(1,'Restarting bg train monitor. Monitor cls: %s. Worker cls: %s\n',...
        class(bgTrnMonitorObj),class(workerObj));

      workerObj.reset();
      delete(obj.bgTrnMonitor);
      obj.bgTrnMonitor = [];
      obj.bgTrnMonBGWorkerObj = [];
      
      obj.bgTrnStart(bgTrnMonitorObj,workerObj); % xxx TODO
    end

    function bgTrnReset(obj)
      % stop the training monitor
      if ~isempty(obj.bgTrnMonitor)
        delete(obj.bgTrnMonitor);
      end
      obj.bgTrnMonitor = [];      
      if ~isempty(obj.bgTrnMonBGWorkerObj)
        delete(obj.bgTrnMonBGWorkerObj);
      end
      obj.bgTrnMonBGWorkerObj = [];
    end    
    
    function tf = getHasTrained(obj)
      tf = ~isempty(obj.trnLastDMC);
    end
    
    function [tfCanTrain,reason] = canTrain(obj)
      
      tfCanTrain = false;
      reason = '';
      if obj.bgTrnIsRunning
        reason = 'Training is already in progress.';
        return;
      end
      if obj.bgTrkIsRunning,
        reason = 'Tracking is in progress.';
        return;
      end
      
      % For now we do this check here even though the actual parfeval()
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn training monitor.';
        return;
      end

      % AL 20190321 parameters now set at start of retrain
%       if isempty(obj.sPrmAll)
%         reason = 'No tracking parameters have been set.';
%         return;
%       end
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'No cache directory has been set.';
        return;
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        reason = 'Please give your project a name. The project name will be used to identify your trained models on disk.';
        return;
      end
      
      backend = lblObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
      
      if isempty(obj.trnNetType)
        reason = 'Deep net type is empty.';
        return;
      end
      
      if obj.trnNetType==DLNetType.openpose && isempty(lblObj.skeletonEdges)
        reason = 'Please define a skeleton to track with OpenPose.';
        return;
      end
      
      tfCanTrain = true;      
    end
    
    function retrain(obj,varargin)
      
      [wbObj,dlTrnType,oldVizObj] = myparse(varargin,...
        'wbObj',[],...
        'dlTrnType',DLTrainType.New, ...
        'oldVizObj',[] ...
        );
      
      if obj.bgTrnIsRunning
        error('Training is already in progress.');
      end
      
      if obj.bgTrkIsRunning
        error('Tracking is in progress.');
      end
      
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        error('Please give your project a name. The project name will be used to identify your trained models on disk.');
      end      
      
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n');      
      
      if obj.isTrkFiles(),
        
        if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
          res = questdlg('Tracking results exist for previous deep trackers. When training stops, these will be deleted. Continue training?','Continue training?','Yes','No','Cancel','Yes');
          if ~strcmpi(res,'Yes'),
            return;
          end
        end
        
      end
      
      obj.setAllParams(lblObj.trackGetParams());
      
      if isempty(obj.sPrmAll)
        error('No tracking parameters have been set.');
      end

      obj.bgTrnReset();
      if ~isempty(oldVizObj),
        delete(oldVizObj);
      end
      
      modelChain0 = obj.trnName;
      switch dlTrnType
        case DLTrainType.New
          modelChain = datestr(now,'yyyymmddTHHMMSS');
          if ~isempty(modelChain0)
            assert(~strcmp(modelChain,modelChain0));
            fprintf('Training new model %s.\n',modelChain);
          end
        case {DLTrainType.Restart DLTrainType.RestartAug}
          if isempty(modelChain0)
            error('Model has not been trained.');
          end
          modelChain = modelChain0;
          fprintf('Restarting train on model %s.\n',modelChain);
        otherwise
          assert(false);
      end
                  
      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
          obj.trnSpawnBsubDocker(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj);
        case DLBackEnd.AWS
          obj.trnSpawnAWS(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj);          
        otherwise
          assert(false);
      end
      
      % Nothing should occur here as failed trnSpawn* will early return      
    end
    
    function trnPrintLogs(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.printLogfiles();      
    end
    
    function trnPrintModelChainDir(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.dispModelChainDir();
    end
    
    function trnKill(obj)
      if ~obj.bgTrnIsRunning
        error('Training is not in progress.');
      end
      
      obj.bgTrnMonBGWorkerObj.killProcess();      
    end
    
    % update trackerInfo from trnLastDMC
    function updateTrackerInfo(obj)
      
      % info about algorithm and training
      info.algorithm = obj.algorithmNamePretty;
      info.isTraining = obj.bgTrnIsRunning;
              
      if isempty(obj.trnLastDMC),
        info.isTrainStarted = false;
        info.isTrainRestarted = false;
        info.trainStartTS = [];
        info.iterCurr = 0;
        info.iterFinal = nan;
        info.nLabels = 0;
      else
        info.isTrainStarted = true;
        info.isTrainRestarted = strcmp(obj.trnLastDMC(1).trainType,'Restart');
        info.trainStartTS = datenum(unique({obj.trnLastDMC.modelChainID}),'yyyymmddTHHMMSS');
        assert(all(~isnan(info.trainStartTS)));
        info.iterCurr = unique([obj.trnLastDMC.iterCurr]);
        if isempty(info.iterCurr),
          info.iterCurr = 0;
        end
        info.iterFinal = unique([obj.trnLastDMC.iterFinal]);
        info.nLabels = unique([obj.trnLastDMC.nLabels]);
      end
      
      obj.trackerInfo = info;
    end
    
    % set select properties of trackerInfo 
    function setTrackerInfo(obj,varargin)
      
      [iterCurr] = myparse(varargin,'iterCurr',[]);
      ischange = false;
      
      trackerInfo = obj.trackerInfo; %#ok<PROPLC>
      if ~isempty(iterCurr),
        ischange = ischange || iterCurr ~= trackerInfo.iterCurr; %#ok<PROPLC>
        trackerInfo.iterCurr = iterCurr; %#ok<PROPLC>
      end
      if ischange,
        obj.trackerInfo = trackerInfo; %#ok<PROPLC>
      end
      
    end
    
    % return a cell array of strings with information about current tracker
    function [infos] = getTrackerInfoString(obj,doupdate)
      % For OpenPose, consider adding blurb about massaged params
      
      if nargin < 2,
        doupdate = false;
      end
      if doupdate,
        obj.updateTrackerInfo();
      end
      infos = {};
      infos{end+1} = obj.trackerInfo.algorithm;
      if obj.trackerInfo.isTrainStarted,
        isNewLabels = any(obj.trackerInfo.trainStartTS < obj.lObj.lastLabelChangeTS);

        infos{end+1} = sprintf('Train start: %s',datestr(min(obj.trackerInfo.trainStartTS)));
        if numel(obj.trackerInfo.iterCurr) > 1,
          scurr = mat2str(obj.trackerInfo.iterCurr);
        else
          scurr = num2str(obj.trackerInfo.iterCurr);
        end
        if numel(obj.trackerInfo.iterFinal) > 1,
          sfinal = mat2str(obj.trackerInfo.iterFinal);
        else
          sfinal = num2str(obj.trackerInfo.iterFinal);
        end
        infos{end+1} = sprintf('N. iterations: %s / %s',scurr,sfinal);
        if isempty(obj.trackerInfo.nLabels),
          nlabelstr = '?';
        elseif numel(obj.trackerInfo.nLabels) == 1,
          nlabelstr = num2str(obj.trackerInfo.nLabels);
        else
          nlabelstr = mat2str(obj.trackerInfo.nLabels);
        end          
        infos{end+1} = sprintf('N. labels: %s',nlabelstr);
        if isNewLabels,
          s = 'Yes';
        else
          s = 'No';
        end
        infos{end+1} = sprintf('New labels since training: %s',s);
        
        sPrmAllLabeler = obj.lObj.trackGetParams();
        sPrmAllAsSet = obj.massageParamsIfNec(sPrmAllLabeler,'throwwarnings',false);
        args = {'trackerAlgo',obj.algorithmName,'hasTrx',obj.lObj.hasTrx,'trackerIsDL',true};
        
        if isempty(obj.sPrmAll),
          isParamChange = true;
          isParamChangeLbler = true;
        else
          isParamChange = ~APTParameters.isEqualFilteredStructProperties(...
            obj.sPrmAll,sPrmAllAsSet,args{:});
          isParamChangeLbler = ~APTParameters.isEqualFilteredStructProperties(...
            obj.sPrmAll,sPrmAllLabeler,args{:});
        end
        if isParamChange,
          s = 'Yes';
        else
          s = 'No';
        end
        infos{end+1} = sprintf('Parameters changed since training: %s',s);
        
        if isParamChangeLbler
          if ~isParamChange
            assert(obj.trnNetType==DLNetType.openpose || obj.trnNetType==DLNetType.leap);
          end
          infos{end+1} = sprintf('Parameter adjustment: %s',obj.trnNetType.prettyString);
        end        
      else
        infos{end+1} = 'No tracker trained.';
      end
      
    end
    
    function props = propList(obj)
      props = obj.trnNetType.timelinePropList;
    end
    
    function [augims,dataAugDir] = dataAug(obj,ppdata,varargin)
      
      [sPrmAll,dataAugDir] = myparse(varargin,...
        'sPrmAll',[],'dataAugDir','' ...
        );
      
      if isempty(sPrmAll),
        sPrmAll = obj.sPrmAll;
      end
      if isempty(sPrmAll)
        error('Tracking parameters not set.');
      end
      sPrmAll = obj.lObj.addExtraParams(sPrmAll);
      
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
%       projname = lblObj.projname;
%       if isempty(projname)
%         error('Please give your project a name. The project name will be used to identify your trained models on disk.');
%       end
            
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n');      

      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
          [augims,dataAugDir] = obj.dataAugBsubDocker(ppdata,sPrmAll,...
            trnBackEnd,'dataAugDir',dataAugDir);
        case DLBackEnd.AWS
          error('not implemented');
          %obj.trnSpawnAWS(trnBackEnd,modelChain,'wbObj',wbObj);    
        otherwise
          assert(false);
      end
    end
    
    function dmc = restoreFromCacheDir(obj,cachedir)
      % EXPERIMENTAL/DEV use at own risk
      
      warningNoTrace('Development/experimental codepath!');
      fprintf(1,'Setting current tracking parameters; these are assumed to be the same as used to train.\n');
      obj.setAllParams(obj.lObj.trackGetParams());
      
      assert(~obj.lObj.isMultiView,'Currently unsupported for multiview projects.');
      
      % Stuff from here on might be a DMC mirror meth
      
      dmc = DeepModelChainOnDisk(...
        'rootDir',cachedir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',0,...
        'modelChainID','',...  % tbd
        'trainID','',... % tbd
        'trainType',DLTrainType.New,...
        'iterFinal','',... %tbd
        'isMultiView',false,...
        'reader',DeepModelChainReader.createFromBackEnd(obj.lObj.trackDLBackEnd),...
        'filesep',obj.filesep...
        );
      
      dd = dir(dmc.dirViewLnx);
      dd = dd(3:end);
      assert(isscalar(dd),'Multiple model chain IDs found in %s. Cannot restore.',dmc.dirModelChainLnx);
      dmc.modelChainID = dd.name;
      
      dd = dir(fullfile(dmc.dirModelChainLnx,'deepnet-*.index'));
      tfsucc = dmc.updateCurrInfo();
      if tfsucc
        fprintf(1,'Found latest trained model with iteration %d.\n',dmc.iterCurr);
      else
        error('Error finding trained model.');
      end
      
      dd = dir(fullfile(dmc.dirProjLnx,'*.lbl'));
      assert(isscalar(dd),'Could not find a unique stripped lblfile in %s',dmc.rootDir);
      toks = regexp(dd.name,'(?<mcID>[0-9T]+)_(?<trnID>[0-9T]+).lbl','names');
      if isempty(toks)
        error('Could not find a unique stripped lblfile in %s',dmc.rootDir);
      end
      if ~strcmp(toks.mcID,dmc.modelChainID)
        error('ModelChainID mismatch: %s vs %s.',toks.mcID,dmc.modelChainID);
      end
      
      dmc.trainID = toks.trnID;
      
      fprintf('Loading stripped lbl %s...\n',dmc.lblStrippedLnx);
      s = load(dmc.lblStrippedLnx,'-mat');
      dmc.nLabels = s.nLabels;
      fprintf('... success, %d labels.\n',s.nLabels);
      
      % ok we made it this far; copy the model into the current
      % DLCacheDir, otherwise APT acts funny, prob due to save machinery
      % expecting models to live under current cache etc.
      dmc2 = dmc.copy();
      dmc2.rootDir = obj.lObj.DLCacheDir;
      assert(exist(dmc2.dirModelChainLnx,'dir')==0,'Dir %s already exists.',dmc2.dirModelChainLnx);
      cmd = sprintf('mkdir -p %s',dmc2.dirModelChainLnx);
      tfsucc = DeepTracker.syscmd(cmd,'dispcmd',true);
      if ~tfsucc
        error('Failed to create dir %s.',dmc2.dirModelChainLnx);
      end
      fprintf(1,'Copying trained model into current cache...\n');
      [tfsucc,msg] = copyfile(dmc.dirModelChainLnx,dmc2.dirModelChainLnx);
      if ~tfsucc
        error('Failed to copy model: %s.',msg);
      end
      [tfsucc,msg] = copyfile(dmc.lblStrippedLnx,dmc2.lblStrippedLnx);
      if ~tfsucc
        error('Failed to copy model: %s.',msg);
      end
      
      obj.trnLastDMC = dmc2;
      obj.trainCleanup();
    end
    
  end
  methods
    %% BSub Trainer
      
    function trnSpawnBsubDocker(obj,backEnd,trnType,modelChainID,varargin)
      %
      % backEnd: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set
      %
      % TODO break up bsub/docker sep meths

      [wbObj] = myparse(varargin,...
        'wbObj',[]... 
        );
      
      % (aws check instance running)
      
      cacheDir = obj.lObj.DLCacheDir;
      
      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      
      % (aws update remote repo)

      nvw = obj.lObj.nview;
      isMultiViewTrain = false;
      nTrainJobs = nvw;
      if backEnd.type == DLBackEnd.Docker || backEnd.type == DLBackEnd.Conda,
        % how many gpus do we have available?
        gpuids = backEnd.getFreeGPUs(nvw);
        if numel(gpuids) < nvw,
          if nvw == 1 || numel(gpuids)<1,
              error('No GPUs with sufficient RAM available locally');
          else
            gpuids = gpuids(1);
            isMultiViewTrain = true;
            nTrainJobs = 1;
          end
        end
      end
      
       % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...   
        'rootDir',cacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',isMultiViewTrain,...
        'reader',DeepModelChainReader.createFromBackEnd(backEnd),...
        'filesep',obj.filesep...
        );

      switch backEnd.type
        case DLBackEnd.Bsub
          aptroot = backEnd.bsubSetRootUpdateRepo(cacheDir);
        case {DLBackEnd.Conda,DLBackEnd.Docker},
          aptroot = APT.Root;
          obj.downloadPretrainedWeights('aptroot',aptroot); 
      end
      
      % create/ensure stripped lbl; set trainID
      tfGenNewStrippedLbl = trnType==DLTrainType.New || trnType==DLTrainType.RestartAug;
      
      trnCmdType = trnType;
      
      if tfGenNewStrippedLbl
        s = obj.trnCreateStrippedLbl('wbObj',wbObj);
        % store nLabels in dmc
        dmc.nLabels = s.nLabels;
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmc.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;

        dlLblFileLcl = dmc.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
        % read nLabels from stripped lbl file
        dmc.readNLabels();
         
        % if no training has actually happened, do not restart, just start
        % anew
        obj.updateLastDMCsCurrInfo();
        isPartiallyTrained = true;
        for i = 1:numel(obj.trnLastDMC),
          isPartiallyTrained = isPartiallyTrained && obj.trnLastDMC(i).isPartiallyTrained();
        end
        if ~isPartiallyTrained,
          trnCmdType = DLTrainType.New;
        end
        
      end

      % At this point
      % We have (modelChainID,trainID). stripped lbl is on disk. 

      syscmds = cell(nvw,1);
      mntPaths = obj.genContainerMountPathBsubDocker(backEnd);
      
      switch backEnd.type
        case DLBackEnd.Bsub
          singArgs = {'bindpath',mntPaths};
          for ivw=1:nvw
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            syscmds{ivw} = DeepTracker.trainCodeGenSSHBsubSingDMC(...
              aptroot,dmc(ivw),...
              'singArgs',singArgs,'trnCmdType',trnCmdType,...
              'bsubargs',{'gpuqueue' obj.jrcgpuqueue 'nslots' obj.jrcnslots});
          end
        case DLBackEnd.Docker
          containerNames = cell(nTrainJobs,1);
          logcmds = cell(nTrainJobs,1);
          syscmds = cell(nTrainJobs,1);
          for ivw=1:nvw,
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            if ivw <= nTrainJobs,
            gpuid = gpuids(ivw);
            [syscmds{ivw},containerNames{ivw}] = ...
                DeepTracker.trainCodeGenDockerDMC(dmc(ivw),backEnd,mntPaths,gpuid,...
                'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType);
            logcmds{ivw} = sprintf('%s logs -f %s &> "%s" &',...
              backEnd.dockercmd,containerNames{ivw},dmc(ivw).trainLogLnx);
            end
          end
        case DLBackEnd.Conda
          condaargs = {'condaEnv',obj.condaEnv};
          for ivw=1:nvw,
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            if ivw <= nTrainJobs,
              gpuid = gpuids(ivw);
              syscmds{ivw} = ...
                DeepTracker.trainCodeGenCondaDMC(dmc(ivw),gpuid,...
                'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType,...
                'condaargs',condaargs);
            end
          end
        otherwise
          assert(false);
      end
      
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backEnd,dmc);
        
        bgTrnWorkerObj = obj.bgTrnMonBGWorkerObj;
        
        % spawn training
        if backEnd.type==DLBackEnd.Docker
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [st,res] = system(syscmds{iview});
            if st==0
              bgTrnWorkerObj.parseJobID(res,iview);
              
              fprintf(1,'%s\n',logcmds{iview});
              [st2,res2] = system(logcmds{iview});
              if st2==0
              else
                fprintf(2,'Failed to spawn logging job for view %d: %s.\n\n',...
                  iview,res2);
              end
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        elseif backEnd.type==DLBackEnd.Conda
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [job,st,res] = parfevalsystem(syscmds{iview});
            if ~st,
              bgTrnWorkerObj.parseJobID(job,iview);
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        else
          bgTrnWorkerObj.jobID = nan(1,nTrainJobs);
          assert(nTrainJobs==numel(dmc));
          for iview=1:nTrainJobs
            syscmdrun = syscmds{iview};
            fprintf(1,'%s\n',syscmdrun);
            
            cmdfile = dmc(iview).cmdfileLnx;
            %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
            [fh,msg] = fopen(cmdfile,'w');
            if isequal(fh,-1)
              warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
            else
              fprintf(fh,'%s\n',syscmdrun);
              fclose(fh);
              fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
            end
            
            [st,res] = system(syscmdrun);
            if st==0
              PAT = 'Job <(?<jobid>[0-9]+)>';
              stoks = regexp(res,PAT,'names');
              if ~isempty(stoks)
                jobid = str2double(stoks.jobid);
              else
                jobid = nan;
                warningNoTrace('Failed to ascertain jobID.');
              end
              fprintf('Training job (view %d) spawned, jobid=%d.\n\n',...
                iview,jobid);
              % assigning to 'local' workerobj, not the one copied to workers
              bgTrnWorkerObj.jobID(iview) = jobid;
            else
              fprintf('Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end
          end
        end        
        obj.trnLastDMC = dmc;
      end
    end
    
    function [augims,dataAugDir] = dataAugBsubDocker(obj,ppdata,...
        sPrmAll,backEnd,varargin)
      
      [dataAugDir] = myparse(varargin,'dataAugDir','');
      
      cacheDir = obj.lObj.DLCacheDir;

      tfLblFileExists = false;
      if ~isempty(dataAugDir) && exist(dataAugDir,'dir'),
        dlLblFileLcl = fullfile(dataAugDir,'dataaug.lbl');
        if exist(dlLblFileLcl,'file'),
          tfLblFileExists = true;
        end
        [~,ID] = fileparts(dataAugDir);
      end
            
      if tfLblFileExists,
        s = load(dlLblFileLcl,'-mat','trackParams','trackerData');
        s.trackParams = sPrmAll;
        ITRKER_SLBL = 2;
        s.trackerData{ITRKER_SLBL}.sPrmAll = sPrmAll;
        save(dlLblFileLcl,'-struct','s','-append');
        fprintf('Reusing cached lbl file %s\n',dlLblFileLcl);
      else
        s = obj.trnCreateStrippedLbl('ppdata',ppdata,'sPrmAll',sPrmAll);
        ID = datestr(now,'yyyymmddTHHMMSS');
        dataAugDir = fullfile(cacheDir,'DataAug',ID);
        if ~exist(dataAugDir,'dir'),
          [succ,msg] = mkdir(dataAugDir);
          if ~succ
            error('Failed to create dir %s: %s',dataAugDir,msg);
          end
        end
        % Write stripped lblfile to local cache
        dlLblFileLcl = fullfile(dataAugDir,'dataaug.lbl');
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
      end
      
      errfile = fullfile(dataAugDir,'dataaug.err');
      outfile = fullfile(dataAugDir,'dataaug');
      
      switch backEnd.type
        case DLBackEnd.Bsub
          aptroot = backEnd.bsubSetRootUpdateRepo(cacheDir,'copyptw',false);          
        case DLBackEnd.Docker
        case DLBackEnd.Conda
      end
      
      switch backEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Docker}
          mntPaths = obj.genContainerMountPathBsubDocker(backEnd);
        case DLBackEnd.Conda
      end
      
      switch backEnd.type
        case DLBackEnd.Bsub
          singArgs = {'bindpath',mntPaths};
          syscmd = DeepTracker.dataAugCodeGenSSHBsubSing(...
            ID,dlLblFileLcl,cacheDir,errfile,obj.trnNetType,outfile,...
            'singArgs',singArgs);
        case DLBackEnd.Docker
          dockerargs = {'detach',false};
          [syscmd] = ...
            DeepTracker.dataAugCodeGenDocker(backEnd,...
            ID,dlLblFileLcl,cacheDir,errfile,obj.trnNetType,outfile,...
            'mntPaths',mntPaths,'dockerargs',dockerargs);
        case DLBackEnd.Conda
          error('Not implemented'); % TODO
        otherwise
          assert(false);
      end
      
      if backEnd.type==DLBackEnd.Docker,
        
        fprintf(1,'%s\n',syscmd);
        [st,res] = system(syscmd);
        
        tfsucc = (st == 0) && ~isempty(regexp(res,'Augmented data saved to','once'));
        if tfsucc,
          [tfsucc,augims] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
          if ~tfsucc,
            error('Error loading augmented data');
          end
        else
          error('Error creating sample augmented images:\n%s',res);
        end
        
      else
        
        fprintf(1,'%s\n',syscmd);
        [st,res] = system(syscmd);
        if st==0,
          PAT = 'Job <(?<jobid>[0-9]+)>';
          stoks = regexp(res,PAT,'names');
          if ~isempty(stoks),
            jobid = str2double(stoks.jobid);
            
            cmd =  @() DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
            nout = 1;
            maxWaitTime = 60; % seconds
            [tfsucc,augims] = DeepTracker.waitForBsubComplete(jobid,cmd,nout,maxWaitTime,true);
            if ~tfsucc,
              error('Data augmentation did not complete within %d seconds',maxWaitTime);
            end
            augims = augims{1};
          else
            error('Failed to ascertain jobID.');
          end
        else
          error('Error creating sample augmented images:\n%s',res);
        end
      end
      
    end
    
    function paths = genContainerMountPathBsubDocker(obj,backend,varargin)
      
      [aptroot,extradirs] = myparse(varargin,...
        'aptroot',[],'extra',{});
      
      assert(backend.type==DLBackEnd.Bsub || backend.type==DLBackEnd.Docker);
      
      if isempty(aptroot)
        switch backend.type
          case DLBackEnd.Bsub
            aptroot = backend.bsubaptroot;
          case DLBackEnd.Docker
            % could add prop to backend for this but 99% of the time for 
            % docker the backend should run the same code as frontend
            aptroot = APT.Root; 
        end
      end
      
      if ~isempty(obj.containerBindPaths)
        assert(iscellstr(obj.containerBindPaths),'containerBindPaths must be a cellstr.');
        fprintf('Using user-specified container bind-paths:\n');
        paths = obj.containerBindPaths;
      elseif backend.jrcsimplebindpaths && backend.type==DLBackEnd.Bsub
        fprintf('Using JRC container bind-paths:\n');
        paths = {'/groups';'/nrs'};
      else
        lObj = obj.lObj;
        
        macroCell = struct2cell(lObj.projMacrosGetWithAuto());
        cacheDir = obj.lObj.DLCacheDir;
        assert(~isempty(cacheDir));
        
        mfaf = lObj.movieFilesAllFull;
        tfaf = lObj.trxFilesAllFull;
        mfafgt = lObj.movieFilesAllGTFull;
        tfafgt = lObj.trxFilesAllGTFull;
        
        projbps = cell(0,1);
        projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,mfaf,'.movieFilesAllFull');
        if ~isempty(mfafgt)
          projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,mfafgt,'.movieFilesAllGTFull');
        end
        if lObj.hasTrx
          projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,tfaf,'.trxFilesAllFull');
          if ~isempty(tfafgt)
            projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,tfafgt,'.trxFilesAllGTFull');
          end
        end
        
%         % add in home directory and their ancestors
%         homedir = getuserdir;
%         homeancestors = [{homedir},getpathancestors(homedir)];
%         if isunix,
%           homeancestors = setdiff(homeancestors,{'/'});
%         end
        
        fprintf('Using auto-generated container bind-paths:\n');
        dlroot = [aptroot '/deepnet'];
        paths = [cacheDir;dlroot;macroCell(:);projbps(:);extradirs(:)];
        paths = unique(paths);
      end
      
      cellfun(@(x)fprintf('  %s\n',x),paths);
    end   
    
    function updateLastDMCsCurrInfo(obj)
      dmcs = obj.trnLastDMC;
      for i=1:numel(dmcs)
        dmcs(i).updateCurrInfo();
      end
    end
    
  end
  methods (Static)
    function basepaths = hlpAugBasePathsWithWarn(basepaths,newpaths,descstr)
      bps = FSPath.commonbase(newpaths);
      if isempty(bps)
        % no nonempty common base found, ie common base is '/'
        warningNoTrace('No common base path found for %s.',descstr);
      else
        fprintf(1,'Found base path ''%s'' for %s.\n',bps,descstr);
        basepaths{end+1,1} = bps;
      end
    end    
  end
  %% AWS Trainer    
  methods
      
    function trnSpawnAWS(obj,backend,trnType,modelChainID,varargin)
      %
      % backend: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set
      
      [wbObj] = myparse(varargin,...
        'wbObj',[]... 
        );
            
      aws = backend.awsec2;
      if isempty(aws)
        error('AWSec2 object not set.');
      end
      aws.checkInstanceRunning(); % harderrs if instance isn't running
      
      backend.awsUpdateRepo();
      
      nvw = obj.lObj.nview;

      % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...        
        'rootDir',backend.RemoteAWSCacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',nvw>1,... % currently all multiview projs train serially
        'reader',DeepModelChainReader.createFromBackEnd(backend),...
        'filesep',obj.filesep...
        );
      dmcLcl = dmc.copy();
      dmcLcl.rootDir = obj.lObj.DLCacheDir;
      
      % create/ensure stripped lbl, local and remote
      tfGenNewStrippedLbl = trnType==DLTrainType.New || ...
                            trnType==DLTrainType.RestartAug;
                          
      if tfGenNewStrippedLbl        
        s = obj.trnCreateStrippedLbl('awsRemote',true,'wbObj',wbObj); 
        % store nLabels in DMC
        dmc.nLabels = s.nLabels;
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        
        % MK 2019018. Creating the cache dir in case it does not exist
        % realized later that cache dir should exist by default.
        % so commenting it out for now, but might be useful.
%         dlCacheDir = fileparts(dlLblFileLclDir);
%         if exist(dlCacheDir,'dir')==0
%           fprintf('Creating local dir: %s\n',dlCacheDir);
%           [succ,msg] = mkdir(dlCacheDir);
%           if ~succ
%             error('Failed to create local dir %s: %s',dlCacheDir,msg);
%           end
%         end
        
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating local dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create local dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file locally: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;

        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing local stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find local stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
        dmcLcl.restartTS = dmc.restartTS;
        % read nLabels from stripped lbl file
        dmcLcl.readNLabels();
        dmc.nLabels = dmcLcl.nLabels;
      end
      dlLblFileRemote = dmc.lblStrippedLnx;
      aws.scpUploadOrVerifyEnsureDir(dlLblFileLcl,dlLblFileRemote,'training file');
      
      % At this point
      % We have (modelChainID,trainID), dlLblFileRemote. remote is ready to 
      % train
      
      % gen DMCs
      for ivw=1:nvw
        if ivw>1
          dmc(ivw) = dmc(1).copy();
        end
        dmc(ivw).view = ivw-1; % 0-based
      end

      % codegen
      % Multiview train is currently serial (no -view flag spec'd)
      % - single logfile
      % - single errfile
      codestr = obj.trainCodeGenAWS(dmc(1)); % all dmcs identical save for view flag
      logfileRemote = dmc(1).trainLogLnx;
      syscmds = { aws.sshCmdGeneralLogged(codestr,logfileRemote) };
            
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backend,dmc);

        % spawn training
        syscmdrun = syscmds{1};
        fprintf(1,'%s\n',syscmdrun);
        system(syscmdrun);
        fprintf('Training job spawned.\n\n');

        % record local cmdfile
        cmdfile = dmcLcl.cmdfileLnx; % currently writes "...viewNan..." since view is not set; this is benign
        %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
        [fh,msg] = fopen(cmdfile,'w');
        if isequal(fh,-1)
          warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
        else
          fprintf(fh,'%s\n',syscmdrun);
          fclose(fh);
          fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
        end
        
        pause(3.0); % Hack try to more reliably get PID -- still not 100% AL 20190130
        aws.getRemotePythonPID(); % Conceptually, bgTrnWorkerObj should
            % remember. Right now there is only one PID per aws so it's ok
        
        obj.trnLastDMC = dmc;
      end
    end
        
    function ppdata = fetchPreProcData(obj,tblP,ppPrms)
      % Fetch preprocessed data per this tracker. Don't update any cache
      % b/c the preproc params supplied may be "trial"/random.
      % 
      % tblP: MFTable
      % ppPrms: scalar struct, preproc params only.
      % 
      % ppdata: CPRData
            
      %ppdb = obj.lObj.ppdb;
      ppdb = PreProcDB();
      ppdb.init();
      [~,ppdata] = ppdb.add(tblP,obj.lObj,'prmpp',ppPrms,'computeOnly',true);
    end
        
    function s = trnCreateStrippedLbl(obj,varargin)
      % 
      % - Mutates .trnTblP
      % - can update .lObj.ppdb
      % - Uploads trxs via AWS (maybe obsolete now)
      % - Can throw
      
      [awsRemote,wbObj,ppdata,sPrmAll] = myparse(varargin,...
        'awsRemote',false,...
        'wbObj',[],...
        'ppdata',[],...
        'sPrmAll',[]...
        );
      
      [tfsucc,tblPTrn,s] = obj.lObj.trackCreateDeepTrackerStrippedLbl(...
         'wbObj',wbObj,'ppdata',ppdata,'sPrmAll',sPrmAll);
      if ~tfsucc
        error('Failed to create DL stripped lbl file.');
      end
      if isempty(ppdata),
        obj.trnTblP = tblPTrn;
      end
      
      ITRKER_SLBL = 2;
      assert(s.trackerData{ITRKER_SLBL}.trnNetType==obj.trnNetType);
      
      % for images, deepnet will use preProcData; trx files however need
      % to be uploaded
            
      if awsRemote 
        % 1. The moviefiles in s should be not be used; deepnet should be
        % reading images directly from .preProcData_I. Fill s.movieFilesAll
        % with jibber as an assert.
        % 2. The trxfiles in s refer to local files; for AWS training we
        % will need them to refer to remote locs.
        %   a. For each trxfile that appears in the training data, we
        %      upload it and replace all appropriate rows of s.trxFilesAll.
        %   b. For all other rows of s.trxFilesAll, we replace with jibber
        %      as an assert.

        % Originally we uploaded trxfiles but this is no longer nec since
        % training relies on the cache which is now pre-rotated etc etc
        
        s.movieFilesAll(:) = {'__UNUSED__'};
        if obj.lObj.hasTrx
          s.trxFilesAll(:) = {'__UNUSED__'};
        end
      end
    end
    
%     function trnCompleteCbkAWS(obj,res)      
%       bgWorker = obj.bgTrnMonBGWorkerObj;
%       % use the aws from here, guess .lObj.trackDLBackEnd could have changed? Hmmmmm
%       aws = bgWorker.awsEc2; 
%       
%       obj.updateLastDMCsCurrInfo();
%       
%       dmc = obj.trnLastDMC;
%        
%         % download trkfiles 
%         sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
%         for ivw=1:numel(res)
%           trkLcl = trkfilesLocal{ivw};
%           trkRmt = res(ivw).trkfile;
%           aws.scpDownload(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs);
%         end
%     end
    
  end
  
  %% Splits
  methods (Static)
    function j = tblSplt2Json(tblSplit,isplit)
      % tblSplit: [nlbledrows x 4] table. cols are MFT and 'split'.
      %  tblSplit.split should be a 1-based (positive) int
      
      tfTst = tblSplit.split == isplit;
      tblTrn = tblSplit(~tfTst,MFTable.FLDSID);
      tblTst = tblSplit(tfTst,MFTable.FLDSID);
      j = jsonencode({tblTrn{:,:} tblTst{:,:}});
    end
  end
  methods 
    function trainsplit(obj,tblSplit,varargin)
      % tblSplit: [nlbledrows x 4] table. cols are MFT and 'split'.
      %  tblSplit.split should be a 1-based (positive) int
      %  
      % Any labeled rows not in tblSplit get added to tstfold 1 I guess.
      %
      % In future, can support more general splits as the splits need not
      % perfectly partition tLbl.

      [wbObj] = myparse(varargin,...
        'wbObj',[] ...
        );
                 
      assert(obj.lObj.nview==1,'Currently only supported for single-view.');

      % --- C+P retrain ---
      if obj.bgTrnIsRunning
        error('Training is already in progress.');
      end
      
      if obj.bgTrkIsRunning
        error('Tracking is in progress.');
      end
      
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        error('Please give your project a name. The project name will be used to identify your trained models on disk.');
      end      
      
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n');
      % --- C+P retrain ---

%       assert(trnBackEnd.type==DLBackEnd.Bsub,...
%         'Currently only supported for JRC Cluster backend.');
%       
      obj.setAllParams(lblObj.trackGetParams());
      
      if isempty(obj.sPrmAll)
        error('No tracking parameters have been set.');
      end

      slbl = obj.trnCreateStrippedLbl('wbObj',wbObj);
      tLbl = table(slbl.preProcData_MD_mov,slbl.preProcData_MD_frm,...
        slbl.preProcData_MD_iTgt,'VariableNames',{'mov' 'frm' 'iTgt'});
      
      tblSplit.mov = double(tblSplit.mov);
      tf = ismember(tLbl,tblSplit(:,MFTable.FLDSID));
      nMissing = nnz(~tf);
      if nMissing>0
        warningNoTrace('%d labeled training rows not found in split table. These will be added to split 1.',nMissing);
        tblSplit = [tblSplit; tLbl(~tf,:)];
      end
      tf = ismember(tblSplit(:,MFTable.FLDSID),tLbl);
      nExtra = nnz(~tf);
      if nExtra>0
        warningNoTrace('Ignoring %d extraneous (unlabeled) rows in split table.',nExtra);
        tblSplit(~tf,:) = [];
      end
      
      splits = tblSplit.split;
      assert(isequal(round(splits),splits));
      assert(all(splits>0));
      nSplits = max(splits);
      assert(isequal(unique(splits),(1:nSplits)'));

      fprintf(1,'Split summary:\n');
      summary(categorical(splits));
      
      obj.bgTrnReset();
      
      cacheDir = obj.lObj.DLCacheDir;
      
      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      

      trnType = DLTrainType.New;

      % Base DMC, to be further copied/specified per-split
      dmc = DeepModelChainOnDisk(...
        'rootDir',cacheDir,...
        'projID',projname,...
        'netType',char(obj.trnNetType),...
        'view',0,...  % 0b
        'modelChainID','',... % to be filled in
        'trainID','',... % to be filled in
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',false,...
        'reader',DeepModelChainReader.createFromBackEnd(trnBackEnd),...
        'filesep',obj.filesep,...
        'doSplit',true ...
        );

      nvw = obj.lObj.nview;
      isMultiViewTrain = false;
      nTrainJobs = nvw;
%       if backEnd.type == DLBackEnd.Docker || backEnd.type == DLBackEnd.Conda,
%         % how many gpus do we have available?
%         gpuids = obj.getFreeGPUs(nvw);
%         if numel(gpuids) < nvw,
%           if nvw == 1 || numel(gpuids)<1,
%               error('No GPUs with sufficient RAM available locally');
%           else
%             gpuids = gpuids(1);
%             isMultiViewTrain = true;
%             nTrainJobs = 1;
%           end
%         end
%       end

      switch trnBackEnd.type
        case DLBackEnd.Bsub
          aptroot = trnBackEnd.bsubSetRootUpdateRepo(cacheDir);
        case {DLBackEnd.Conda,DLBackEnd.Docker},
          assert(false);
          aptroot = APT.Root;
          %obj.downloadPretrainedWeights('aptroot',aptroot); 
      end
            
      trnCmdType = trnType;

      % LOOP STUFF
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      dmc.modelChainID = DeepModelChainOnDisk.modelChainIDForSplit(nowstr,1);
      dmc.trainID = nowstr;
      
      % Write stripped lblfile to local cache
      dlLblFileLcl = dmc.lblStrippedLnx;
      dlLblFileLclDir = fileparts(dlLblFileLcl);
      if exist(dlLblFileLclDir,'dir')==0
        fprintf('Creating dir: %s\n',dlLblFileLclDir);
        [succ,msg] = mkdir(dlLblFileLclDir);
        if ~succ
          error('Failed to create dir %s: %s',dlLblFileLclDir,msg);
        end
      end
      save(dlLblFileLcl,'-mat','-v7.3','-struct','slbl');
      fprintf('Saved stripped lbl file: %s\n',dlLblFileLcl);

      %dmc.nLabels = slbl.nLabels;
            
      % At this point
      % We have (modelChainID,trainID). stripped lbl is on disk. 

      syscmds = cell(nvw,1);
      %switch trnBackEnd.type
      %  case DLBackEnd.Bsub
          
      %  case DLBackEnd.Docker 
      %    fprintf(2,'UNCMT JRC\n');
          %assert(false);
          %mntPaths = obj.genContainerMountPath();          
      %end
      
      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Docker}
          mntPaths = obj.genContainerMountPathBsubDocker(trnBackEnd);
          singArgs = {'bindpath',mntPaths};
          for isplit=1:nSplits
                        
            if isplit>1
              dmc(isplit) = dmc(1).copy();
              dmc(isplit).modelChainID = ...
                DeepModelChainOnDisk.modelChainIDForSplit(nowstr,isplit); 
              dmc(isplit).lblStrippedNameOverride = dmc(1).lblStrippedName;
            end
            dmc(isplit).nLabels = nnz(tblSplit.split~=isplit);
            
            jsplit = DeepTracker.tblSplt2Json(tblSplit,isplit);
            jsplitfile = dmc(isplit).splitfileLnx;
            fh = fopen(jsplitfile,'wt');
            try
              fprintf(fh,'%s\n',jsplit);
            catch ME
              fclose(fh);
              rethrow(ME);
            end
            fclose(fh);
            fprintf(1,'... saved splitfile %s\n',jsplitfile);

            syscmds{isplit} = DeepTracker.trainCodeGenSSHBsubSingDMC(...
              aptroot,dmc(isplit),...
              'singArgs',singArgs,'trnCmdType',trnCmdType,...
              'bsubargs',{'gpuqueue' obj.jrcgpuqueue 'nslots' obj.jrcnslots});
          end
%         case DLBackEnd.Docker
%           containerNames = cell(nTrainJobs,1);
%           logcmds = cell(nTrainJobs,1);
%           syscmds = cell(nTrainJobs,1);
%           for ivw=1:nvw,
%             if ivw>1
%               dmc(ivw) = dmc(1).copy();
%             end
%             dmc(ivw).view = ivw-1; % 0-based
%             if ivw <= nTrainJobs,
%             gpuid = gpuids(ivw);
%             [syscmds{ivw},containerNames{ivw}] = ...
%                 DeepTracker.trainCodeGenDockerDMC(dmc(ivw),backEnd,mntPaths,gpuid,...
%                 'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType);
%             logcmds{ivw} = sprintf('%s logs -f %s &> "%s" &',...
%               obj.dockercmd,containerNames{ivw},dmc(ivw).trainLogLnx);
%             end
%           end
%         case DLBackEnd.Conda
%           condaargs = {'condaEnv',obj.condaEnv};
%           for ivw=1:nvw,
%             if ivw>1
%               dmc(ivw) = dmc(1).copy();
%             end
%             dmc(ivw).view = ivw-1; % 0-based
%             if ivw <= nTrainJobs,
%               gpuid = gpuids(ivw);
%               syscmds{ivw} = ...
%                 DeepTracker.trainCodeGenCondaDMC(dmc(ivw),gpuid,...
%                 'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType,...
%                 'condaargs',condaargs);
%             end
%           end
        otherwise
          assert(false);
      end
      
      %be = obj.lObj.trackDLBackEnd;
      
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(trnBackEnd,dmc,'trainSplits',true);
        
        bgTrnWorkerObj = obj.bgTrnMonBGWorkerObj;
        
        % spawn training
        if trnBackEnd.type==DLBackEnd.Docker
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [st,res] = system(syscmds{iview});
            if st==0
              bgTrnWorkerObj.parseJobID(res,iview);
              
              fprintf(1,'%s\n',logcmds{iview});
              [st2,res2] = system(logcmds{iview});
              if st2==0
              else
                fprintf(2,'Failed to spawn logging job for view %d: %s.\n\n',...
                  iview,res2);
              end
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        elseif trnBackEnd.type==DLBackEnd.Conda
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [job,st,res] = parfevalsystem(syscmds{iview});
            if ~st,
              bgTrnWorkerObj.parseJobID(job,iview);
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        else
          nTrainJobs = numel(dmc);
          bgTrnWorkerObj.jobID = nan(1,nTrainJobs);
          assert(nTrainJobs==numel(dmc));
          for iview=1:nTrainJobs
            syscmdrun = syscmds{iview};
            fprintf(1,'%s\n',syscmdrun);
            
            cmdfile = dmc(iview).cmdfileLnx;
            %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
            [fh,msg] = fopen(cmdfile,'w');
            if isequal(fh,-1)
              warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
            else
              fprintf(fh,'%s\n',syscmdrun);
              fclose(fh);
              fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
            end
            
            if exist(dmc(iview).dirTrkOutLnx,'dir')==0
              [succ,msg] = mkdir(dmc(iview).dirTrkOutLnx);
              if succ
                fprintf(1,'Made dir ''%s''.\n',dmc(iview).dirTrkOutLnx);
              else
                error('Failed to create dir ''%s'': %s',dmc(iview).dirTrkOutLnx,...
                  msg);
              end
            end                
            
            [st,res] = system(syscmdrun);
            if st==0
              PAT = 'Job <(?<jobid>[0-9]+)>';
              stoks = regexp(res,PAT,'names');
              if ~isempty(stoks)
                jobid = str2double(stoks.jobid);
              else
                jobid = nan;
                warningNoTrace('Failed to ascertain jobID.');
              end
              fprintf('Training job (view %d) spawned, jobid=%d.\n\n',...
                iview,jobid);
              % assigning to 'local' workerobj, not the one copied to workers
              bgTrnWorkerObj.jobID(iview) = jobid;
            else
              fprintf('Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end
          end
        end        
        obj.trnSplitLastDMC = dmc;
      end
      
      % Nothing should occur here as failed trnSpawn* will early return
      
    end
  end
  
  %% Track  
  methods (Static)
    function [gpuids,isMultiView,isSerialMultiMov] = ...
                        trackGPUAllocate(nmovset,nview,gpuidsall)
      % Decide how to break up a batch tracking job across GPUs
      %
      % We take as given a (conceptual) [nmovset x nview] array of movies 
      % to be tracked. Meanwhile the GPUs available are provided in gpuids.
      %
      % gpuidsall should be ordered in reverse GPU desirability, ie earlier
      % GPUs are used first.
      %
      % gpuids: GPUs to use; shape determined by isMultiView/isSerialMultiMov.
      % isMultiView: true if tracking across views is done serially for each movset
      % isSerialMultiMov: true if tracking across movs is done serially
      %   (assumes nview==1 currently)

      % this can be made much better!
      nmovs = nmovset*nview;
      ngpuall = numel(gpuidsall);
      if ngpuall>=nmovs
        % track all movs in parallel
        gpuids = gpuidsall(1:nmovs);
        gpuids = reshape(gpuids,[nmovset nview]);
        isMultiView = false;
        isSerialMultiMov = false;
      elseif ngpuall>=nmovset 
        % each movset gets a GPU, serial tracking across views.
        % Note this is theoretical atm as callers probably have nmovset==1
        % when nview>1.
        gpuids = gpuidsall(1:nmovset);
        gpuids = gpuids(:);
        isMultiView = true;
        isSerialMultiMov = false;
      elseif nview==1     
        gpuids = gpuidsall(1);
        isMultiView = false;
        isSerialMultiMov = true;
      elseif ngpuall >= nview,
        % each view gets a gpu
        gpuids = gpuidsall(1:nview);
        isMultiView = false;
        isSerialMultiMov = true;
      else
        % put everything on one gpu
        gpuids = gpuidsall(1);
        isMultiView = true;
        isSerialMultiMov = true;
%         % Shouldn't come up yet 
%         assert(false,'Unsupported tracking modality');
      end
      
      fprintf(1,'Allocating %d*%d movs to track across %d available gpus:\n',...
        nmovset,nview,ngpuall);
      fprintf(1,'... using %d gpus, multiview=%d, serialmov=%d\n',...
        numel(gpuids),isMultiView,isSerialMultiMov);
    end
  end
  methods
    
    % Tracking timeline
    % - Call to track. We are talking a single movie right now.
    % - .trnLastDMC must be set. The current backend behavior is the most 
    % recent model in <cache>/.../trnName will be used
    % - BG track monitor started. This polls the filesys for the output
    % file.
    % - Spawn track shell call.
    % - When tracking is done for a view, movIdx2trkfile is updated.
    % - When tracking is done for all views, we stop the bgMonitor and we
    % are done.
    
    function track(obj,tblMFT,varargin)
      % Apply trained tracker to the specified frames.
      % 
      % tblMFT: MFTable with cols MFTable.FLDSID
      
      if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      if obj.bgTrnIsRunning && obj.lObj.trackDLBackEnd.type==DLBackEnd.AWS
        % second clause is really, "only have 1 GPU avail"
        % AWS, currently we are testing with p2.xlarge and p3.2xlarge which
        % are single-GPU EC2 instances. multi-GPU instances are avail
        % however.
        error('Tracking while training is in progress is currently unsupported on AWS.');
      end
      
      isexternal = iscell(tblMFT);
      
      sPrmLabeler = obj.lObj.trackGetParams();
      sPrmSet = obj.massageParamsIfNec(sPrmLabeler);
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
          obj.didParamsChange(sPrmSet);
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged
        warningNoTrace('Deep Learning parameters have changed since your last retrain.');
        % Keep it simple for now. Note training might be in progress but
        % even if not etc.
      end
      
      obj.setPostProcParams(sPrmSet);
      % Specifically allow/support case where tfPostProcChanged is true
      % to enable turning off/on postproc or trying diff pp algos with a 
      % given trained tracker   
      
      obj.bgTrkReset();
        
      % track an external movie. See trackGPUAllocate for supported
      % tracking modalities.
      if isexternal
        movfiles = tblMFT;
        % cropRois: if tfexternal, cell array of [nviewx4]
        [trxfiles,trkfiles,f0,f1,cropRois,targets,iview,...
          calibrationfiles,calibrationdata] = myparse(varargin,...
          'trxfiles',{},'trkfiles',{},'f0',[],'f1',[],'cropRois',{},'targets',{},...
          'iview',nan,... % used only if tfSerialMultiMov; CURRENTLY UNSUPPORTED
          'calibrationfiles',{},...
          'calibrationdata',{}...
          );
        assert(size(movfiles,2)==obj.lObj.nview,'movfiles must be nmovies x nviews');
        [nmovies,nviews] = size(movfiles); 
        
        if obj.lObj.hasTrx,
          assert(all(size(trxfiles)==size(movfiles)),...
            'Trx files must be input and size(trxfiles) must match size(movfiles).');
        end
        if ~isequal(size(trkfiles),size(movfiles))
          error('Output trkfile array must have exactly the same size as input movie array.');
        end

        if isempty(cropRois),
          % Note this format differs from ~isexternal branch
          cropRois = repmat({[]},nmovies,1);
        end
        
        tfdefaulttgts = false;
        if isempty(targets),
          targets = repmat({[]},[nmovies,1]);
          tfdefaulttgts = true;
        end
        
        trkfilesexist = cellfun(@exist,trkfiles);
        if any(trkfilesexist(:)),
          trkfilesdelete = trkfiles(trkfilesexist>0);
          trkfilesdelete = trkfilesdelete(:);
          ndel = numel(trkfilesdelete);
          MAXTRKFILESDEL = 8;
          if ndel <= MAXTRKFILESDEL
            qstr = [{'The following output trk files already exist. Delete them?'};trkfilesdelete];
          else
            qstr = sprintf('The following output trk files (%d total) already exist. Delete them?',ndel);
            qstr = [{qstr}; trkfilesdelete(1:MAXTRKFILESDEL); {'...<snip>...'}];
          end
          res = questdlg(qstr,'Delete existing trk files?','Delete','Cancel','Cancel');
          if strcmpi(res,'Delete'),
            for i = 1:numel(trkfilesdelete),
              delete(trkfilesdelete{i});
            end
          else
            return;
          end
        end

        % KB 20200504 Now supported!!
%         if obj.lObj.nview>1 && ~strcmp(obj.sPrmAll.ROOT.PostProcess.reconcile3dType,'none')
%           msg = '3D reconciliation is currently not supported for external movie tracking. Tracking results will not be postprocessed or reconciled in 3D. ';
%           uiwait(msgbox(msg,'3D Reconciliation','modal'));
%         end
      end
      
      if ~isexternal && isempty(tblMFT)
        warningNoTrace('Nothing to track.');
        return;
      end
      
      if obj.bgTrnIsRunning,
        assert(obj.lObj.trackDLBackEnd.type~=DLBackEnd.AWS);
        obj.updateLastDMCsCurrInfo();
        iterCurr = zeros(size(obj.trnLastDMC));
        for i = 1:numel(obj.trnLastDMC),
          ic = obj.trnLastDMC(i).iterCurr;
          if isempty(ic) || isnan(ic)
            iterCurr(i) = 0;
          else
            iterCurr(i) = ic;
          end
        end
        iterCurr = min(iterCurr);
        if iterCurr == 0,
          % AL updated msg to be palatable for both single and multi-views
          % (in the latter case you may have a tracker for one view but not
          % another)
          warndlg('Training in progress, and in-progress tracker(s) has not been saved yet. Please wait to track.','Tracker not ready','modal'); 
          return;
        end
        res = questdlg(sprintf('Training in progress. Tracking will use in-progress tracker, which has been trained for %d / %d iterations. When training completes, these frames will need to be retracked. Continue?',...
          iterCurr,obj.trnLastDMC(1).iterFinal),'Use in-progress tracker?','Track','Cancel','Track');
        if strcmpi(res,'Cancel'),
          return;
        end
      end
                    
      % check trained tracker
      if isempty(obj.trnName)
        error('No trained tracker found.');
      end

      dmc = obj.trnLastDMC;
      backend = obj.lObj.trackDLBackEnd;

      if backend.type==DLBackEnd.AWS
        setStatusFcn = @(varargin)obj.lObj.SetStatus(varargin{:});
        backend.awsPretrack(dmc,setStatusFcn);
      end
      
      obj.updateTrackerInfo();
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      if ~isexternal,
        isCurr = obj.checkTrackingResultsCurrent();
        if ~isCurr,
          
          if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
            res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Cancel','Delete');
            if strcmpi(res,'Cancel'),
              return;
            end
            if strcmpi(res,'Retrack'),
              tblMFTRetrack = obj.getTrackedMFT();
              ism = ismember(tblMFTRetrack,tblMFT);
              tblMFT = [tblMFT;tblMFTRetrack(~ism,:)];
            end
          end
          obj.cleanOutOfDateTrackingResults(isCurr);
        end

        % figure out what to track
        tblMFTTracked = obj.getTrackedMFT();
        tblMFT0 = tblMFT;
        tblMFT = MFTable.tblDiff(tblMFT0,tblMFTTracked);
        if isempty(tblMFT),
          msgbox(sprintf('All %d frames previously tracked',size(tblMFT0,1)),'Tracking done');
          return;
        end
        
        tblMFT = MFTable.sortCanonical(tblMFT);
        mIdx = unique(tblMFT.mov);
        if ~isscalar(mIdx)
          error('Tracking only single movies is currently supported.');
        end
        tMFTConc = obj.lObj.mftTableConcretizeMov(tblMFT);
        
        fprintf(1,'\n');
        
        tftrx = obj.lObj.hasTrx;
        if tftrx % can prob do away with this conditional
          f0 = min(tblMFT.frm);
          f1 = max(tblMFT.frm);
          % More complex version of warning below would apply
        else
          f0 = tblMFT.frm(1);
          f1 = tblMFT.frm(end);
%           if ~isequal((f0:f1)',tblMFT.frm)
%             warningNoTrace('Tracking additional frames to form continuous sequence.');
%           end
        end
               
        if obj.lObj.cropProjHasCrops
          assert(~tftrx);
          cropInfo = obj.lObj.getMovieFilesAllCropInfoMovIdx(mIdx);
          cropRois = cat(1,cropInfo.roi);
        else
          cropRois = [];
        end        
      end

      tfHeatMap = ~isempty(obj.trkGenHeatMaps) && obj.trkGenHeatMaps;
      if tfHeatMap
        hmapArgs = {'hmaps' true};
      else
        hmapArgs = {};
      end
      
      % Could check here that for local dmcs, dmc.rootDir matches
      % obj.lObj.DLCacheDir (as in canTrack()). However the assertion that
      % the local stripped lbl exists probably suffices
      
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(obj.lObj.DLCacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      assert(exist(dlLblFileLcl,'file')>0);
      
      switch backend.type
        case DLBackEnd.Bsub,
          if isexternal,
            args = {};
            if obj.lObj.hasTrx,
              args = {'trxfiles',trxfiles,'targets',targets};
            end
            % this is not going to work for multiple movies. TODO: fix
            tfSuccess = obj.trkSpawn(backend,[],[],dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'movfiles',movfiles,'trkfiles',trkfiles,...
              'calibrationfiles',calibrationfiles,args{:});
          else
            tfSuccess = obj.trkSpawn(backend,mIdx,tMFTConc,dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1);
          end
          if ~tfSuccess,
            obj.bgTrkReset();
            return;
          end
          
        case {DLBackEnd.Docker,DLBackEnd.Conda},

          isMultiViewTrack = false;
          isSerialMultiMovTrack = false;
          if isexternal,
            % TODO: see docker track other branch below
            gpuidsall = backend.getFreeGPUs(nmovies*nviews);
            if isempty(gpuidsall),
              warndlg('No GPUs available with sufficient RAM locally','Error tracking','modal');
              return;
            end
            
            [gpuids,isMultiViewTrack,isSerialMultiMovTrack] = ...
                        DeepTracker.trackGPUAllocate(nmovies,nviews,gpuidsall);
            
            if isSerialMultiMovTrack && tfdefaulttgts
              targets = []; % otherwise default val is a [nmovset] cell array
            end
          else
            if obj.trkDockerCPU
              gpuids = [];
              isMultiViewTrack = true;
            else
              gpuids = backend.getFreeGPUs(obj.lObj.nview);
              if isempty(gpuids)
                % On linux, we couldn't find GPUs
                % On win, .getFreeGPUs probably didn't play well with Docker
                % on Windows (ie didnt do the intended query) but anyway we
                % currently don't support GPU tracking on this codepath
                
                if ispc
                  qstr = 'GPU tracking on Windows currently unsupported. Perform tracking on CPU?';
                else
                  qstr = 'No GPUs available with sufficient RAM locally. Perform tracking on CPU?';
                end
                tstr = 'GPU Tracking Unavailable';
                btn = questdlg(qstr,tstr,'Yes','No/Cancel','Yes');
                if isempty(btn)
                  btn = 'No/Cancel';
                end
                switch btn
                  case 'Yes'
                    isMultiViewTrack = true;
                  case 'No/Cancel'
                    %warndlg('No GPUs available with sufficient RAM locally','Error tracking','modal');
                    return;
                end
              elseif numel(gpuids) < obj.lObj.nview,
                isMultiViewTrack = true;
              else
                isMultiViewTrack = false;
              end
            end
          end
          
          args = {'isMultiView',isMultiViewTrack,...
                  'isSerialMultiMov',isSerialMultiMovTrack};
          if isempty(gpuids)
            args = [args {'isgpu' false}];
          end
          
          if isexternal,
            if obj.lObj.hasTrx,
              args = [args,{'trxfiles',trxfiles,'targets',targets}];
            end
            tfSuccess = obj.trkSpawn(backend,[],[],dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'movfiles',movfiles,...
              'trkfiles',trkfiles,'calibrationfiles',calibrationfiles,...
              'gpuids',gpuids,args{:});
          else
            tfSuccess = obj.trkSpawn(backend,mIdx,tMFTConc,dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'gpuids',gpuids,args{:});
          end
          if ~tfSuccess,
            obj.bgTrkReset();
            return;
          end

        case DLBackEnd.AWS
          % TODO: AWS gpu provisioning
          %args = {'isMultiView',isMultiViewTrack,'isSerialMultiMov',true};
          if isexternal,
            args = {};
            if obj.lObj.hasTrx,
              args = [args,{'trxfiles',trxfiles,'targets',targets}];
            end
            tfSuccess = obj.trkSpawn(backend,[],[],dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'movfiles',movfiles,'trkfiles',trkfiles,...
              'calibrationfiles',calibrationfiles,args{:});
          else
            obj.trkSpawn(backend,mIdx,tMFTConc,dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'isMultiView',true);
          end
        otherwise
          assert(false);
      end
    end
    
    % AL20191220 GT classification
    % track2() is an alternate codepath that is refactored relative to 
    % track(). Over time we may be able to migrate track() over to 
    % track2(). Currently track2 handles trackListFile and trackGT.
    %
    % track2 operates in more stages to hopefully facilitate modularity and
    % extensibility:
    % 1. pre-track, error-checking and preliminaries
    %   1a. updating of remote repos, downloading PTWs, etc
    % 2. marshalling of base trksysinfo structure containing modelfiles,
    % logfiles, etc
    % 3. customization of trksysinfo depending on task
    % 4. task-specific code generation
    % 5. (optional) early-return, dry run
    % 6. backend-specific bg monitor launch
    % 7. backend-specific track process spawn
    
    function track2_pretrack(obj)
      
      %%% Prechecks %%%
      
      if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      
%      be = obj.lObj.trackDLBackEnd;
%       if be.type~=DLBackEnd.Bsub
%         % to be lifted later
%         error('Currently only supported for JRC Cluster backend.');
%       end
      
      if obj.bgTrnIsRunning
        % Could probably support, but training currently does a
        % "rolling-cleanout" and this track could take a while, plus, like
        % why.
        error('Unsupported while training is in progress.');
      end
      
      if isempty(obj.trnName)
        error('No trained tracker found.');
      end
      
      %%% Params %%%

      sPrmLabeler = obj.lObj.trackGetParams();
      sPrmSet = obj.massageParamsIfNec(sPrmLabeler);
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
          obj.didParamsChange(sPrmSet);
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged
        warningNoTrace('Deep Learning parameters have changed since your last retrain.');
        % Keep it simple for now. Note training might be in progress but
        % even if not etc.
      end
      
      obj.setPostProcParams(sPrmSet);
      % Specifically allow/support case where tfPostProcChanged is true
      % to enable turning off/on postproc or trying diff pp algos with a 
      % given trained tracker
      if obj.lObj.isMultiView && ~strcmp(obj.sPrmAll.ROOT.PostProcess.reconcile3dType,'none')
        % GT specific msg!
        msg = 'GT assessments are currently performed in each view independently. No 3D reconciliation will be done.';
        uiwait(msgbox(msg,'3D Reconciliation','modal'));
      end 
      
      be = obj.lObj.trackDLBackEnd;
      cchdir = obj.lObj.DLCacheDir;
      dmc = obj.trnLastDMC;
      setStatusFcn = @obj.lObj.SetStatus;
      be.pretrack(cchdir,dmc,setStatusFcn);

      % why not; done in track()
      obj.updateTrackerInfo();
    end
    
    function trkjobsGT = track2_genBaseTrkInfo(obj,taskKeywords,varargin)
      % taskKeyword: arbitrary string/keyword for log/errfiles etc
 
%       gtResaveStrippedLbl = myparse(varargin,...
%         'gtResaveStrippedLbl',false ... % if true, resave *GT props to stripped lbl
%         );

      nvw = obj.lObj.nview;
      assert(numel(taskKeywords)==nvw);

      %%% DMC %%% 
      
      % Calling this now as it is called later in getTrkFileTrnStr and we
      % are copying the dmcs here
      obj.updateLastDMCsCurrInfo();      
      dmc = obj.trnLastDMC;
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      for i=1:nvw
        dmc(i).trkTaskKeyword = taskKeywords{i};
        dmc(i).trkTSstr = nowstr;
      end
      
      lclCacheDir = obj.lObj.DLCacheDir;
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(lclCacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      assert(exist(dlLblFileLcl,'file')>0,...
        'Can''t find stripped lbl file: %s\n',dlLblFileLcl);
      
      % generate stripped lbl for GT cache
      [tfsucc,~,slblgt] = obj.lObj.trackCreateDeepTrackerStrippedLbl(...
        'shuffleRows',false);
      if ~tfsucc
        error('Failed to create DL stripped lbl file.');
      end
      flds = fieldnames(slblgt);
      fldsPP = flds(startsWith(flds,'preProcData'));
      sgt = structrestrictflds(slblgt,fldsPP);
      
      lds = load(dlLblFileLcl,'-mat');
      gtchanged = ~isfield(lds,'gtcache') || ~isequaln(lds.gtcache,sgt);
      if gtchanged
        % Note simply re-creating the entire stripped lbl might alter
        % training data (movies labels etc) which would be highly
        % undesirable.
        
        fprintf('GT labels have changed since train...\n');
        
        % back up existing stripped lbl jic
        nowstr = datestr(now,'yyyymmddTHHMMSS');
        lblbak = sprintf('%s_%s.bak',dlLblFileLcl,nowstr);
        [succ,msg] = copyfile(dlLblFileLcl,lblbak);
        if ~succ
          error('Error resaving stripped lbl: %s',msg);
        end
        fprintf('Backed up stripped lbl: %s.\n',dlLblFileLcl);
        
        %% load and resave.
        lds.gtcache = sgt;
        save(dlLblFileLcl,'-mat','-v7.3','-struct','lds');
        fprintf('Resaved stripped lbl with updated GT state.\n');
      end
      
%       if gtResaveStrippedLbl
%         % Modify&resave stripped lbl if nec, as GT movies labels etc
%         % may have changed since training. Currently we classify/track GT
%         % using APT_interf -classify_gt which reads GT rows from the
%         % stripped lbl. Alternatively we could just make a listfile etc and
%         % track the "normal" way which would prob be better.
% 
%         lds = load(dlLblFileLcl,'-mat');
%         snew = obj.lObj.projGetSaveStruct('macroreplace',true,...
%                                           'massageCropProps',true,...
%                                           'savepropsonly',true);
%         gtprops = obj.lObj.SAVEPROPS_GTCLASSIFY;
%         somethingGTchanged = ~isequaln(structrestrictflds(lds,gtprops),...
%                                        structrestrictflds(snew,gtprops));        
     
%       end

      %%% Code/PTW %%% 
      
      be = obj.lObj.trackDLBackEnd;
      
      % right now, always create a single TrackJobGT to run serially across
      % views. This is simpler as it works for all backends and the number
      % of GT rows should be manageable.
      trkjobsGT = TrackJobGT(be,dmcLcl,dmc,obj.trnNetType);

%       aptroot = be.bsubaptroot; % should be set previously during pretrack      
%       %%% Marshall base trksysinfo %%%      
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
%       trksysinfo = struct(...
%         'trkinfotimestamp',repmat({nowstr},size(trnstrs(:))),...
%         'aptroot',repmat({aptroot},size(trnstrs(:))),...
%         'dmcRootDir',{dmc.rootDir}',...
%         'lblStrippedLnx',{dmc.lblStrippedLnx}',...
%         'trkoutdir',{dmc.dirTrkOutLnx}',...
%         'trnstr',trnstrs(:),...
%         'modelfile',modelFiles(:),...
%         'logfile',[],...
%         'errfile',[],...
%         'snapshotfile',[],...
%         'codestr',[]);
%       
%       for ivw=1:nvw
%         trnstr = trksysinfo(ivw).trnstr;
%         trkoutdir = trksysinfo(ivw).trkoutdir;
%         
%         args = {taskKeywords{ivw},trnstr,ivw,nowstr};
%         logfile = fullfile(trkoutdir,sprintf('%s_%s_vw%d_%s.log',args{:}));
%         errfile = fullfile(trkoutdir,sprintf('%s_%s_vw%d_%s.err',args{:}));
%         ssfile  = fullfile(trkoutdir,sprintf('%s_%s_vw%d_%s.aptsnapshot',args{:}));    
%         trksysinfo(ivw).logfile = logfile;
%         trksysinfo(ivw).errfile = errfile;
%         trksysinfo(ivw).snapshotfile = ssfile;
%       end
    end
    
    function track2_codegen_gt(obj,tj)
      % gt-specific trksysinfo massage + codegen
      
      tj.codegen();
%       nvw = obj.lObj.nview;
%       modelChainID = obj.trnName;
%       
%       for ivw=1:nvw
%         
%         trkoutdir = tj(ivw).trkoutdir;
%         gtoutfileBase  = sprintf('gtcls_vw%d_%s',ivw,tj(ivw).trkinfotimestamp);
%         gtoutfile = [trkoutdir '/' [gtoutfileBase '.mat']];
%         partfile = [gtoutfile '.part'];
%         tj(ivw).outfile = gtoutfile;
%         tj(ivw).partfile = partfile;
%         tj(ivw).codestr = DeepTracker.trackCodeGenGTClassifySSHBsubSing(...
%           tj(ivw),modelChainID,obj.trnNetType,ivw,...          
%           'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
%           'sshargs',sshargsuse);
%       end
    end
        
    function trksysinfo = track2_codegen_listfile(obj,trksysinfo,listfiles,outfiles)
      % trackListFile-specific trksysinfo massage + codegen
      
      nvw = obj.lObj.nview;
      assert(isequal(nvw,numel(listfiles),numel(outfiles)));

      modelChainID = obj.trnName;
      
      for ivw=1:nvw
        trksysinfo(ivw).listfile = listfiles{ivw};
        trksysinfo(ivw).outfile = outfiles{ivw};
        trksysinfo(ivw).partfile = ''; % for now
        aptroot = trksysinfo(ivw).aptroot;
        logfile = trksysinfo(ivw).logfile;
        
        baseargs = {'deepnetroot' [aptroot '/deepnet']};
        baseargsaug = [baseargs {'model_file' trksysinfo(ivw).modelfile}];
        bsubargs = {'outfile' logfile};
        sshargs = {};
        listfileroot = fileparts(listfiles{ivw});        
        singBind = obj.genContainerMountPath('aptroot',aptroot,...
          'extra',{listfileroot}); % XXX ood api
        singargs = {'bindpath',singBind};
        repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
        repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,trksysinfo(ivw).snapshotfile);
        prefix = [DLBackEndClass.jrcprefix '; ' repoSScmd];
        sshargsuse = [sshargs {'prefix' prefix}];
        
        trksysinfo(ivw).codestr = DeepTracker.trackCodeGenListFileSSHBsubSing(...
          trksysinfo(ivw),modelChainID,obj.trnNetType,ivw,...          
          'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
          'sshargs',sshargsuse);
      end
    end
    
    function track2_bgStart(obj,trkjobs,cbkTrkComplete,nfrms2trk)
      % Start track monitor. This stuff mirrors what is done in (and 
      % downstream) of .track()
      
      % nfrms2trk: currently used just so viz knows when "done" is.
      % Something feels off here, bgStart doesn't need to know something
      % like nfrms2trk. This is a viz thing. So maybe bgStart accepts the
      % viz etc. Def not a big deal, so we are making the viz here too.

      assert(isempty(obj.bgTrkMonitor));
      
      sztj = size(trkjobs);
      logfiles = reshape({trkjobs.mntrLogfile},sztj);
      errfiles = reshape({trkjobs.mntrErrfile},sztj);
%       if isMultiView,
%         outfiles = reshape(cat(1,trksysinfo.trkfile),[nMovies,nView]);
%         partfiles = reshape(cat(1,trksysinfo.parttrkfile),[nMovies,nView]);        
%       else
      outfiles = reshape({trkjobs.mntrOutfile},sztj);
      partfiles = reshape({trkjobs.mntrPrtfile},sztj);
      
      nvw = obj.lObj.nview;
      dmc = obj.trnLastDMC; % tj.dmcsrem?
      be = obj.lObj.trackDLBackEnd;
      bgTrkWorkerObj = DeepTracker.createBgTrkWorkerObj(nvw,dmc,be);
            
      %mIdxDummy = MovieIndex(1); % not used for anything
      movsDummy = repmat({'__UNUSED__'},1,nvw);
      bgTrkWorkerObj.initFiles(movsDummy,...
        outfiles(:)',logfiles(:)',errfiles(:)',partfiles(:)',false);  
      % for now always true for track2* codepath
      %bgTrkWorkerObj.setPartfileIsTextStatus(true);

      tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
      if any(tfErrFileErr)
        error('There is an existing error in an error file: ''%s''.',...
          String.cellstr2CommaSepList(errfiles));
      end
      
      bgTrkMonitorObj = BgTrackMonitor;
      
      %nFramesTrack = obj.getNFramesTrack(tMFTConc,mIdx,frm0,frm1,trxids);
      %fprintf('Requested to track %d frames, through interface will track %d frames.\n',size(tMFTConc,1),nFramesTrack)
      
      %trkVizObj = feval(obj.bgTrkMonitorVizClass,nView,obj,bgTrkWorkerObj,backend.type,nFramesTrack);
      %trkVizObj = TrkTrnMonVizCmdline();
      trkVizObj = feval(obj.bgTrkMonitorVizClass,nvw,obj,bgTrkWorkerObj,be.type,nfrms2trk);
      bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,cbkTrkComplete);
      %bgTrkMonitorObj.prepare(bgTrkWorkerObj,@obj.trkCompleteCbk);
      
      addlistener(bgTrkMonitorObj,'bgStart',@(s,e)disp('bgStart') ); % @(s,e)obj.notify('trackStart'));
      addlistener(bgTrkMonitorObj,'bgEnd',@(s,e)disp('bgEnd')); % @(varargin) obj.trackStoppedCbk(varargin{:}));
      
      obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);        
    end
    
    function [tfSuccess,msg] = track2_spawn(obj,tjs)
      % spawns jobs per trksysinfo and sets obj.trksysinfo, unless
      % .dryRunOnly is true.
      
      tfSuccess = true;
      msg = '';
      
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.codestr),tjs);
      else
        % Actually do things
        
        ntj = numel(tjs);
        for itj=1:ntj
          % You might think this should be done in pretrack, but what is
          % done here is TrackJobGT-dependent as it depends on how the task
          % is broken up in to TrackJobGTs. So this location (or any place
          % post TJ-creation seems correct for now).
          tjs(itj).checkCreateDirs();
          

          fprintf(1,'%s\n',tjs(itj).codestr);
          [st,res] = system(tjs(itj).codestr);
          if st==0
            fprintf('Tracking job %d spawned:\n%s\n',itj,res);
          else
            tfSuccess = false;
            msg = sprintf('Failed to spawn tracking job for view %d: %s.\n\n',...
              itj,res);
            % remaining views not even attempted apparently; or, earlier
            % views already spawned but we early-return anyway
            return;
          end
          
          logcmd = tjs(itj).codestrlog;
          if ~isempty(logcmd)
            [st,res] = system(logcmd);
            if st~=0,
              fprintf(2,'Error logging docker job %s: %s\n',...
                tjs(itj).backend.dockerContainerName,res);
              tfSuccess = false;
              return;
            end
          end
        end
        obj.trkSysInfo = tjs;
      end
    end
    
    function [tfSuccess,msg,trksysinfo] = trackListFile(obj,listfiles,outfiles)
      assert(false,'Currently unsupported.');

      listfiles = cellstr(listfiles);
      outfiles = cellstr(outfiles);
      nvw = obj.lObj.nview;
      assert(isequal(nvw,numel(listfiles),numel(outfiles)));
      
      obj.track2_pretrack();
      
      [~,listfileKeywords,~] = cellfun(@myfileparts,listfiles,'uni',0);      
      trksysinfo = obj.track2_genBaseTrkInfo(listfileKeywords);
      
      trksysinfo = obj.track2_codegen_listfile(trksysinfo,listfiles,outfiles);
       
      [tfSuccess,msg] = obj.track2_spawn(trksysinfo);
    end
    
    function [tfSucc,msg,tj] = trackGT(obj)
      % Track all GT frames in proj.
      % Conceptually similar to trackListFile. Conceptually the list is 
      % comprised of all GT-labeled rows but in practice this is handled in
      % the py.

      tfSucc = false;
      msg = '';
      
      [tfCanTrack,msg] = obj.canTrack();
      if ~tfCanTrack
        return;
      end
      
      tblGT = obj.lObj.labelGetMFTableLabeled('useTrain',0);
      if isempty(tblGT)
        msg = 'Project has no GT frames labeled.';
        return;
      end      
        
      obj.bgTrkReset();

      obj.track2_pretrack();
      
      nvw = obj.lObj.nview;
      kw = repmat({'GT'},nvw,1);
      tj = obj.track2_genBaseTrkInfo(kw,'gtResaveStrippedLbl',true);
      
      obj.track2_codegen_gt(tj);
      
      nfrms2trk = height(tblGT); % a little fragile here
      obj.track2_bgStart(tj,@obj.cbkTrackGTComplete,nfrms2trk);
      
      [tfSucc,msg] = obj.track2_spawn(tj);
    end
    
    function cbkTrackGTComplete(obj,res)
      gtmatfiles = {res.trkfile}';
      tblGT = obj.trackGTgtmat2tbl(gtmatfiles);
      obj.trkGTtrkTbl = tblGT;
      obj.trackGTcompute(tblGT);
    end
    
    function trackGTcompute(obj,tblGT,varargin)
      reportargs = myparse(varargin,...
        'reportargs',{'nmontage',24});
      
      tblMFT_SuggAndLbled = obj.lObj.gtGetTblSuggAndLbled();
      
      lObj = obj.lObj;
      
      % only for check below. this pLbl is read from gtmatfiles which is 
      % produced by the Py
      tblGTpLbl = tblGT.pLbl; 
      tblGT(:,'pLbl') = [];
      lObj.gtComputeGTPerformanceTable(tblMFT_SuggAndLbled,tblGT); % also sets obj.lObj.gtTblRes
      d = tblGTpLbl-lObj.gtTblRes.pLbl;
      GTLBL_THRESH_PX = 1e-2;
      if max(abs(d(:))) > GTLBL_THRESH_PX
        % In cases with trx, crops etc the gtlbls from gtTblRes have been
        % round-tripped thru i) crop/rotate into gt cache and ii) invert
        % back into absolute coords.
        warningNoTrace('Discrepancy encountered in GT labels read from deepnet mat-files.');
      end
      lObj.gtReport(reportargs{:});
      msgbox('GT results available in Labeler property ''gtTblRes''.');
    end
    
    function tblGT = trackGTgtmat2tbl(obj,gtmatfiles,varargin)
      
      GTMATLOCFLD = 'locs';
      GTMATOCCFLD = 'occ';
      
      gtmats = cellfun(@(x)load(x,'-mat'),gtmatfiles); %#ok<LOAD>
      cellfun(@(x)fprintf(1,'Loaded gt output mat-file %s.\n',x),gtmatfiles);
      
      assert(numel(gtmats)==obj.nview);
      if numel(gtmats)>1
        assert(isequal(gtmats.list)); % all mft/metadata tables should match
      end
      
      mft = gtmats(1).list; % should already be 1based from deepnet
      assert(size(mft,2)==3);
      mIdx = MovieIndex(-mft(:,1)); 
      % labeled/pred_locs are [nfrmtrk x nphyspt x 2]
      plbl = cat(2,gtmats.locs_labeled); % now [nfrmtrk x npt x 2]      
      nfrmtrk = size(plbl,1);
      plbl = reshape(plbl,nfrmtrk,[]); % now [nfrmtrk x (npt*2)] where col order is (all x-coords, then all y-)
      ptrk = cat(2,gtmats.(GTMATLOCFLD));
      nfrmtrk = size(ptrk,1);
      ptrk = reshape(ptrk,nfrmtrk,[]);
      assert(isequal(size(plbl),size(ptrk)));
      
      tbltrkMFT = table(mIdx,mft(:,2),mft(:,3),...
        'VariableNames',{'mov' 'frm' 'iTgt'});
      lObj = obj.lObj;
      ppdb = lObj.ppdb;
      nphyspts = lObj.nPhysPoints;
      nvw = lObj.nview;
      sz = [nfrmtrk nphyspts nvw 2];
      pbig = cat(5,reshape(plbl,sz),reshape(ptrk,sz));
      pbig = ppdb.invtform(tbltrkMFT,pbig);
      plblabs = reshape(pbig(:,:,:,:,1),nfrmtrk,[]);
      ptrkabs = reshape(pbig(:,:,:,:,2),nfrmtrk,[]);      
      
      szplbl = size(plbl);
      if isfield(gtmats,GTMATOCCFLD)
        ptrkocc = cat(2,gtmats.(GTMATOCCFLD));
        assert(isequal(size(ptrkocc),[szplbl(1) szplbl(2)/2]));
      else
        ptrkocc = nan(szplbl(1),szplbl(2)/2);
      end
      
      %tfcroplocs = arrayfun(@(x)~isempty(x.crop_locs) && any(~isnan(x.crop_locs(:))),...
      %  gtmats);
      %assert(all(tfcroplocs==tfcroplocs(1)));
      tfcroplocs = false;
      
      tablevars = {plblabs,ptrkabs,ptrkocc};
      tablevarnames = {'pLbl' 'pTrk' 'pTrkocc'};      
      if tfcroplocs(1)
        rois = cat(2,gtmats.crop_locs); % [xlovw1 xhivw1 ylovw1 yhivw1 xlovw2 ...]
        tablevars{end+1} = rois; 
        tablevarnames{end+1} = 'roi'; 
      end            
      tblGT = [tbltrkMFT table(tablevars{:},'VariableNames',tablevarnames)];
    end
        
    function [tfCanTrack,reason] = canTrack(obj)
      tfCanTrack = false;
      reason = '';
      
      if obj.bgTrkIsRunning
        reason = 'Tracking is already in progress.';
        return;
      end
      
      % For now we do this check here even though the actual parfeval() 
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn tracking monitor.';
        return;
      end

      % check trained tracker
      if isempty(obj.trnName)
        reason = 'No trained tracker found.';
        return;
      end
      
      if isempty(obj.sPrmAll),
        reason = 'Training parameters not set.';
        return;
      end

      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'Cache directory not set.';
        return;
      end
      
      backend = obj.lObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
            
      dmc = obj.trnLastDMC;
      for i=1:numel(dmc)
        if ~dmc(i).isRemote && ~strcmp(dmc(i).rootDir,cacheDir)
          reason = 'Cache directory has changed since training.';
          return;
        end
      end
      
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(cacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      if exist(dlLblFileLcl,'file')==0
        reason = sprintf('Cannot find training file: %s\n',dlLblFileLcl);
        return;
      end
      
      tfCanTrack = true;      
    end
    
    function tfSuccess = trkSpawn(obj,backend,mIdx,tMFTConc,dlLblFile,...
        cropRois,baseArgs,frm0,frm1,varargin)
      % cropRois: if isexternal, [nmovset] cell of rois; 
      %           each el is either [] or [nTotalView 4]
      
      tfSuccess = false;
      
      nView = obj.lObj.nview;
      [movs,trxfiles,trxids,trkfiles,calibrationfiles,isgpu,gpuids,isMultiView,...
        isSerialMultiMov,viewSerialMultiMovs] = ...
        myparse(varargin,...
        'movfiles',{},...
        'trxfiles',{},...% used when tfexternal. Either {}, or a 
                      ...% [nmovie x nview] cell array (right now 
                      ...% multiview+trx projs unsupported generally in APT though.)
        'targets',[],... % used when tfexternal. trxids to track. Either
                     ... % [], a [ntargets] vector, or a [nmovie] cell array 
        'trkfiles',{},... 
        'calibrationfiles',{},... % cell array with one entry per movie, empty if no calibration
        'isgpu',true,...
        'gpuids',[],... % optional, but if supplied, precisely the right 
                    ... % number of gpus must be specified ie nMovJobs*nViewJobs
        'isMultiView',false,...
        'isSerialMultiMov',false,... % track external movies serially with a 
                                 ... % single DL call. if true, must have 
                                 ... % (tfexternal && ~isMultiView)
        'iviewSerialMultiMov',1:nView ... % used if isSerialMultiMov=true. view index (1b) to track
        );
      
      isexternal = ~isempty(movs);

      tftrx = obj.lObj.hasTrx;
      
      if isexternal,
        nMovies = size(movs,1);
      else
        nMovies = 1;
      end
      
      % whether we are tracking multiple views in the same job
      if isMultiView,
        nViewJobs = 1; % single job will track all views
      else
        nViewJobs = nView; % one job per view
      end
      
      if isexternal
        % "defaults"
        if isSerialMultiMov
          %assert(isnumeric(trxids)); % applies to all movies
        else
          % Conceptually trxids applies to all views
          if isempty(trxids)
            trxids = cell(nMovies,1);
          else
            assert(iscell(trxids) && numel(trxids)==nMovies);
          end         
        end
        if tftrx
          % Note APT only supports single-view with trx
          szassert(trxfiles,[nMovies nView]);
        else
          trxfiles = cell(nMovies,nView);
        end
      end
      
      cacheDir = obj.lObj.DLCacheDir;
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      
      % see CodeGen comment below, maybe dont need to massage baseArgs here
      switch backend.type
        case DLBackEnd.Bsub
          aptroot = backend.bsubSetRootUpdateRepo(cacheDir); % ptw shouldnt be nec but ok
          baseArgs = [baseArgs {'deepnetroot' [aptroot '/deepnet']}];
        case DLBackEnd.Docker
        case DLBackEnd.Conda
          baseArgs = [baseArgs,{'filesep',obj.filesep}];
      end
      
      %clear trksysinfo;
  
      % Maps to track2/stages 2-3, generation/customization of
      % trksysinfo/TrackJob
      if isSerialMultiMov
        assert(isexternal && ~isMultiView);
        for ivwjob = 1:numel(viewSerialMultiMovs),
          ivw = viewSerialMultiMovs(ivwjob);
          id = sprintf('%s_%dmovs_vw%d',nowstr,nMovies,ivw);
%           if ~isempty(trxids)
%             assert(isnumeric(trxids));
%           end
%           if ~isempty(frm0) || ~isempty(frm1),
%             if ~(isscalar(frm0) && isscalar(frm1))
%               error('''frm0'' and ''frm1'' specifications should be scalars that apply to all movies when tracking multiple movies serially.');
%             end
%           end
          % this is dumb; cropRoi format conversion
          if ~isempty(cropRois),%obj.lObj.cropProjHasCrops
            cropRois_curr = nan(nMovies,4);
            for imv = 1:nMovies,
              if size(cropRois{imv},1) >= ivw,
                cropRois_curr(imv,:) = cropRois{imv}(ivw,:);
              end
            end
            %           assert(nView==1);
            %           cropRois = cat(1,cropRois{:}); % size check done in TrackJob
          else
            assert(all(cellfun(@(x) isempty(x) || all(isnan(x)),cropRois)));
            cropRois_curr = [];
          end
          movs_curr = movs(:,ivw);
          if ~isempty(trxfiles),
            trxfiles_curr = trxfiles(:,ivw);
          else
            trxfiles_curr = {};
          end
          trkfiles_curr = trkfiles(:,ivw);
          trksysinfo(ivwjob) = TrackJob(obj,backend,...
            'targets',trxids,...
            'frm0',frm0,...
            'frm1',frm1,...
            'cropRoi',cropRois_curr,...
            'movfileLcl',movs_curr,...
            'trxfileLcl',trxfiles_curr,...
            'trkfileLcl',trkfiles_curr,...
            'calibrationfileLcl',calibrationfiles,...
            'isMultiView',isMultiView,...
            'isSerialMultiMov',true,...
            'ivw',ivw,...
            'rootdirLcl',cacheDir,...
            'nowstr',id); %#ok<AGROW> % HERE
          trksysinfo(ivwjob).prepareFiles();
          fprintf('View %d: %d trkfiles to be written, first to %s\n',...
            ivw,numel(trkfiles_curr),trksysinfo(ivwjob).trkfileLcl{1});

        end
        
        baseArgs = [baseArgs,{'serialmode' true}]; 
        % see CodeGen comment below, maybe dont need to massage baseArgs here

      else
        for imov = 1:nMovies,
          for ivwjob = 1:nViewJobs,
            
            if isMultiView,
              ivw = 1:nView;
            else
              ivw = ivwjob;
            end
            id = sprintf('%s_mov%d_vwj%d',nowstr,imov,ivwjob);
            if isempty(frm0) && isempty(frm1),
              frm0curr = 1;
              frm1curr = inf;
            elseif isscalar(frm0) && isscalar(frm1)
              % scalar expand. could allow one empty
              frm0curr = frm0;
              frm1curr = frm1;
            else
              frm0curr = frm0(imov);
              frm1curr = frm1(imov);
            end
            
            if isempty(calibrationfiles),
              calibrationfile_curr = '';
            else
              calibrationfile_curr = calibrationfiles{imov};
            end
            
            if isexternal,
              if isnumeric(trxids)
                % scalar expand
                trxidscurr = trxids;
              else
                trxidscurr = trxids{imov};
              end
              % for whatever reason, cropRoi is indexed by view within
              % TrackJob, but rest of arguments are not
              
              trksysinfo(imov,ivwjob) = TrackJob(obj,backend,...
                'targets',trxidscurr,...
                'frm0',frm0curr,...
                'frm1',frm1curr,...
                'cropRoi',cropRois{imov},... 
                'movfileLcl',movs(imov,ivw),...
                'trxfileLcl',trxfiles(imov,ivw),...
                'trkfileLcl',trkfiles(imov,ivw),...
                'calibrationfileLcl',calibrationfile_curr,...
                'isMultiView',isMultiView,...
                'ivw',ivw,...
                'rootdirLcl',cacheDir,...
                'nowstr',id); %#ok<AGROW>
            else
              trksysinfo(imov,ivwjob) = TrackJob(obj,backend,...
                'targets',trxids,...
                'frm0',frm0,...
                'frm1',frm1,...
                'cropRoi',cropRois,...
                'tMFTConc',tMFTConc,...
                'isMultiView',isMultiView,...
                'ivw',ivw,...
                'rootdirLcl',cacheDir,...
                'nowstr',id); %#ok<AGROW>
            end
            trksysinfo(imov,ivwjob).prepareFiles();
            
            for i = 1:numel(trksysinfo(imov,ivwjob).trkfileLcl),
              ivw1 = trksysinfo(imov,ivwjob).ivw(i);
              fprintf('View %d: trkfile will be written to %s\n',ivw1,trksysinfo(imov,ivwjob).trkfileLcl{i});
            end
          end
        end
      end
      
      % Maps to track2/stage 4, codegen
      nMovJobs = size(trksysinfo,1); % might be 1 with multiple movies if isSerialMultiMov
      assert(size(trksysinfo,2)==nViewJobs);
      if ~isempty(gpuids)
        assert(numel(gpuids) == nMovJobs*nViewJobs);
        gpuids = reshape(gpuids,[nMovJobs,nViewJobs]);
      end
      % Each trksysinfo(imovjob,ivwjob) represents one job that will be run 
      % on a single GPU
      % AL: CodeGen is probably fully determined by a TrackJob+BackEnd?
      % If so maybe details, need to specify baseArgs etc dont need to be 
      % here
      for imovjob = 1:nMovJobs,
        for ivwjob = 1:nViewJobs,
          switch backend.type
            case DLBackEnd.Bsub
              bsubargs = {'nslots' obj.jrcnslotstrack 'gpuqueue' obj.jrcgpuqueue};

              % make sure movie to be tracked is on path
              extradirs = trksysinfo(imovjob,ivwjob).getMountDirs();
              singBind = obj.genContainerMountPathBsubDocker(backend,'extra',extradirs); % HERE
              singargs = {'bindpath',singBind};
              
              repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
              repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,trksysinfo(imovjob,ivwjob).snapshotfile);
              prefix = [backend.jrcprefix '; ' repoSScmd];
              %sshargs = {'logfile' outfile2};
              sshargs = {'prefix' prefix};
              
              trksysinfo(imovjob,ivwjob).setCodeStr(...
                'bsubargs',bsubargs,'sshargs',sshargs,...
                'baseargs',baseArgs,'singargs',singargs);
              
            case DLBackEnd.Docker
              % make sure movie to be tracked is on path
              extradirs = trksysinfo(imovjob,ivwjob).getMountDirs();
              singBind = obj.genContainerMountPathBsubDocker(backend,'extra',extradirs);
              if isgpu
                dockerargs = {};
                if isempty(gpuids),
                  % none
                else
                  dockerargs = [dockerargs {'gpuid',gpuids(imovjob,ivwjob)}]; %#ok<AGROW>
                end
              else
                dockerargs = {'isgpu' false 'dockerimg' 'bransonlabapt/apt_docker:latest_cpu'};
              end
              useLogFlag = ispc;
              
              trksysinfo(imovjob,ivwjob).setCodeStr('baseargs',baseArgs,...
                'dockerargs',dockerargs,'mntpaths',singBind,'useLogFlag',useLogFlag);
              
              if useLogFlag
                trksysinfo(imovjob,ivwjob).logcmd = []; 
              else
                trksysinfo(imovjob,ivwjob).logcmd = sprintf('%s logs -f %s &> "%s" &',...
                  backend.dockercmd,trksysinfo(imovjob,ivwjob).containerName,...
                  trksysinfo(imovjob,ivwjob).logfile); 
              end
              
            case DLBackEnd.AWS,
              
              trksysinfo(imovjob,ivwjob).setCodeStr('baseargs',baseArgs);
              
            case DLBackEnd.Conda
              condaargs = {'condaEnv',obj.condaEnv};
              if ~isempty(gpuids),
                condaargs(end+1:end+2) = {'gpuid',gpuids(imovjob,ivwjob)};
              end
              trksysinfo(imovjob,ivwjob).setCodeStr('baseargs',baseArgs,...
                'condaargs',condaargs);
              
            otherwise
              error('Not implemented back end %s',backend.type);
          end
        end
      end
      
      % Maps to track2/stage5 early return
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.codestr),...
          trksysinfo);
        tfSuccess = true;
        return;
      end
      % start track monitor
      assert(isempty(obj.bgTrkMonitor));
      
      % Maps to track2/stage6, bg monitor config/launch
      % The philosophy is currently, there is a single monitor for all
      % tracking jobs.      
      logfiles = reshape({trksysinfo.logfile},size(trksysinfo));
      errfiles = reshape({trksysinfo.errfile},size(trksysinfo));
      if isMultiView,
        assert(~isSerialMultiMov);
        outfiles = reshape(cat(1,trksysinfo.trkfileRem),[nMovies,nView]);
        partfiles = reshape(cat(1,trksysinfo.parttrkfileRem),[nMovies,nView]);
        movfiles = reshape(cat(1,trksysinfo.movfileLcl),[nMovies,nView]);
      elseif isSerialMultiMov
        outfiles = cell(nMovies,numel(trksysinfo));
        partfiles = cell(nMovies,numel(trksysinfo));
        movfiles = cell(nMovies,numel(trksysinfo));
        for ivwjob = 1:numel(trksysinfo),
          outfiles(:,ivwjob) = trksysinfo(ivwjob).trkfileRem(:);
          partfiles(:,ivwjob) = trksysinfo(ivwjob).parttrkfileRem(:);
          movfiles(:,ivwjob) = trksysinfo(ivwjob).movfileLcl(:);
        end
        %assert(nView==1,'Serial tracking supported for single-view only.');
      else
        outfiles = reshape([trksysinfo.trkfileRem],size(trksysinfo));
        partfiles = reshape([trksysinfo.parttrkfileRem],size(trksysinfo));
        movfiles = reshape([trksysinfo.movfileLcl],size(trksysinfo));
      end
      bgTrkWorkerObj = DeepTracker.createBgTrkWorkerObj(nView,obj.trnLastDMC,backend);
      % movfiles is nMovies x nViews
      bgTrkWorkerObj.initFiles(movfiles,outfiles,logfiles,errfiles,...
        partfiles,isexternal);
      
      tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
      if any(tfErrFileErr)
        error('There is an existing error in an error file: ''%s''.',...
          String.cellstr2CommaSepList(errfiles));
      end
      
      bgTrkMonitorObj = BgTrackMonitor;
      
      % KB 20190115: adding trkviz
      nFramesTrack = obj.getNFramesTrack(trksysinfo);
      nFramesTrackSum = sum(nFramesTrack);
      if isexternal,        
        fprintf('Tracking %d frames across %d movies.\n',nFramesTrackSum,...
          numel(nFramesTrack));
      else
        fprintf('Requested to track %d frames, through interface will track %d frames.\n',...
          size(tMFTConc,1),nFramesTrack)
      end
      
      trkVizObj = feval(obj.bgTrkMonitorVizClass,nView,obj,bgTrkWorkerObj,backend.type,nFramesTrack);
      bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,@obj.trkCompleteCbk);
      
      addlistener(bgTrkMonitorObj,'bgStart',@(s,e)obj.notify('trackStart'));
      addlistener(bgTrkMonitorObj,'bgEnd',@(varargin) obj.trackStoppedCbk(varargin{:})); % AL partially dups stuff in .trkCompleteCbk
      
      %bgTrkMonitorObj.prepare(bgTrkWorkerObj,@obj.trkCompleteCbk);
      obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);
      
      % Maps to track2/stage7, spawn jobs
      tfSuccess = true;
      for imovjob=1:nMovJobs,
        for ivwjob=1:nViewJobs,
          
          fprintf(1,'%s\n',trksysinfo(imovjob,ivwjob).codestr);
          if backend.type == DLBackEnd.Conda,
            [job,st,res] = parfevalsystem(trksysinfo(imovjob,ivwjob).codestr);
          else
            [st,res] = system(trksysinfo(imovjob,ivwjob).codestr);
          end
          if st==0
            switch backend.type,
              case DLBackEnd.Conda,
                bgTrkWorkerObj.parseJobID(job,ivwjob,imovjob);
              case DLBackEnd.Docker,
                bgTrkWorkerObj.parseJobID(res,ivwjob,imovjob);
              case DLBackEnd.Bsub,
                bgTrkWorkerObj.parseJobID(res,ivwjob,imovjob);
              case DLBackEnd.AWS
                aws = backend.awsec2;
                pause(5.0); % hack
                aws.getRemotePythonPID();
              otherwise
                error('Not implemented: %s',backend.type);
            end
            fprintf('Tracking job (movie %d, job %d) spawned:\n%s\n',imovjob,ivwjob,res);
          else
            fprintf(2,'Failed to spawn tracking job for movie %d, job %d: %s.\n\n',...
              imovjob,ivwjob,res);
            tfSuccess = false;
            return;
          end
          switch backend.type,
            case DLBackEnd.Docker,
              logcmd = trksysinfo(imovjob,ivwjob).logcmd;
              if ~isempty(logcmd)
                [st,res] = system(logcmd);
                if st~=0,
                  fprintf(2,'Error logging docker job %s: %s\n',...
                    trksysinfo(imovjob,ivwjob).containerName,res);
                  tfSuccess = false;
                  return;
                end
              end
          end
        end
      end
      
      obj.trkSysInfo = trksysinfo;
    end
        
    function nframes = getNFramesTrack(obj,trksysinfo) %#ok<INUSL>
      % This returns a [nmovsettrk] array, the number of frames to be
      % tracked in each movieset.
      %
      % Note that trksysinfo may either be an [nmovssettrk nviewjobs] 
      % TrackJobs array with one row per movieset to be tracked; or it may 
      % be a scalar TrackJobs object with with tfserialmov=true which
      % represents [nmovsettrk] movies in a single object.

      NMOVSET_WB_THRESH = 8;
      
      if isscalar(trksysinfo)
        % could be a single regular TrackJob, or a single TrakcJob with
        % tfserialmov=true
        nframes = trksysinfo.getNFramesTrack();
      else
        [nmovsets,nvjobs] = size(trksysinfo); %#ok<ASGLU>
        maxNSerialMov = max([trksysinfo.nmovsettrk]);        
        nframes = nan(maxNSerialMov,nmovsets);
        
        % AL202101 This call can be *very* slow for batch tracking,
        % depending on nmovsets, codecs, movlengths, etc.
        tfWB = nmovsets>NMOVSET_WB_THRESH; 
        if tfWB
          hWB = WaitBarWithCancel('Tracking',...
            'cancelDisabled',true);
          hWB.startPeriod('Reading movie metadata...','shownumden',1,...
            'denominator',nmovsets);
        end
        for i = 1:nmovsets,
          if tfWB
            hWB.updateFracWithNumDen(i);
          end
          % works if trksysinfo is multiview or not          
          nframes(1:trksysinfo(i,1).nmovsettrk,i) = trksysinfo(i,1).getNFramesTrack();
        end
        nframes = nframes(:);
      end
    end


    function trkPrintTrkOutDir(obj)
%       modelChainID = obj.trnName;
%       if isempty(modelChainID) 
%         error('Training is not complete or in progress.');
%       end
      if ~obj.bgTrkIsRunning
        fprintf('Tracking is not in progress; log is for most recent tracking session.\n');
      end
      bgObj = obj.bgTrkMonBGWorkerObj; % For AWS this can cause trouble because the AWSEC2 instance is 
        % detached
      bgObj.dispTrkOutDir();
    end
  end
  methods (Static)
    function bgTrkWorkerObj = createBgTrkWorkerObj(nView,dmc,backend)
      switch backend.type
        case DLBackEnd.Bsub
          bgTrkWorkerObj = BgTrackWorkerObjBsub(nView,dmc);
        case DLBackEnd.Conda,
          bgTrkWorkerObj = BgTrackWorkerObjConda(nView,dmc);
        case DLBackEnd.Docker,
          bgTrkWorkerObj = BgTrackWorkerObjDocker(nView,dmc,backend);
        case DLBackEnd.AWS,
           bgTrkWorkerObj = BgTrackWorkerObjAWS(nView,dmc,backend.awsec2);
        otherwise
          error('Not implemented back end %s',backend.type);
      end
    end
    function sha = getSHA(file)
      if ismac
        file = strrep(file,' ','\ ');
        shacmd = sprintf('MD5 %s',file);
        [~,res] = DeepTracker.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        res = strtrim(res);
        toks = regexp(res,' ','split');
        sha = toks{end};        
        sha = regexprep(sha,' ','');          
      elseif isunix
        file = strrep(file,' ','\ ');
        shacmd = sprintf('md5sum %s',file);
        [~,res] = DeepTracker.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,' ','split');
        sha = toks{1};        
        sha = regexprep(sha,' ','');
      else
        shacmd = sprintf('certUtil -hashFile "%s" MD5',file);
        [~,res] = DeepTracker.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,'\n','split');
        sha = toks{2};
        sha = regexprep(sha,' ','');
      end
    end
  end
  methods

    function trkPrintLogs(obj)
      btm = obj.bgTrkMonitor;
      if isempty(btm)
        error('Tracking is neither in progress nor complete.');
      end
      btm.bgWorkerObj.printLogfiles();
    end
    
    function bgTrkReset(obj)
      obj.trkSysInfo = [];
      if ~isempty(obj.bgTrkMonitor)
        delete(obj.bgTrkMonitor);
      end
      obj.bgTrkMonitor = [];
      if ~isempty(obj.bgTrkMonBGWorkerObj)
        delete(obj.bgTrkMonBGWorkerObj);
      end
      obj.bgTrkMonBGWorkerObj = [];
    end
    
    function bgTrkStart(obj,trkMonitorObj,trkWorkerObj)
      % fresh start new training monitor 
      % trkMonitorObj: should be 'prepared'
      
      if ~isempty(obj.bgTrkMonitor)
        error('Tracking monitor exists. Call .bgTrkReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrkMonBGWorkerObj));
      
      trkMonitorObj.start();
      obj.bgTrkMonitor = trkMonitorObj;
      obj.bgTrkMonBGWorkerObj = trkWorkerObj;
    end
    
    function trkCompleteCbkOld(obj,res)
      
      isexternal = iscell(res(1).mIdx) || ischar(res(1).mIdx);
      if isexternal,
        % AL: guessing here didn't test
        for i=1:numel(res)
          fprintf('Tracking complete for %s, results saved to %s.\n',...
            res(i).movfile,res(i).trkfile);
        end
        return;
      end
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        
        trkfiles = {res.trkfile}';
        obj.trkPostProcIfNec(mIdx,trkfiles);
        obj.trackResAddTrkfile(mIdx,trkfiles);
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
      
    end
    
    function trkCompleteCbk(obj,res)

      try,
      
      % res is nMovies x nViews
      [nMovSets,nViews] = size(res);
      isexternal = res(1).isexternal;
      
      for i = 1:numel(obj.trkSysInfo),
        obj.trkSysInfo(i).downloadRemoteResults();
      end

      if isexternal,
        if obj.lObj.isMultiView
          % AL 20201116: protected this codepath by checking for multiview.
          % This codepath was broken for 'external' tracking of multiple 
          % (eg 2) movies for a single-view proj.
          for i = 1:nMovSets,
            movfiles = [obj.trkSysInfo(i,:).movfileLcl];
            trkfiles = [obj.trkSysInfo(i,:).trkfileLcl];
            calibrationfile = obj.trkSysInfo(i,1).calibrationfileLcl;
            cropROIs = cat(1,obj.trkSysInfo(i,:).cropRoi);
            obj.trkPostProcIfNec(movfiles,trkfiles,'calibrationfile',calibrationfile,...
              'cropROIS',cropROIs);
          end
        end
        for i=1:nMovSets*nViews,
          fprintf('Tracking complete for %s, results saved to %s.\n',...
            res(i).movfile,res(i).trkfile);
        end
      else
        % AL20200305: we do postproc and update obj.trackRes here. For now
        % now putting this in the ~isexternal branch; "external" tracking
        % will never update DeepTracker results even if the movies are
        % present in the proj etc.
        
        assert(nMovSets==1); % currently true for nonexternal tracking; to be lifted later
        mIdx = repmat(MovieIndex(1),nMovSets,1);
        tffound = false(nMovSets,1);
        for i = 1:nMovSets,
          % This line might be fragile wrt user input for external tracking
          [tffound(i),mIdx(i)] = obj.lObj.getMovIdxMovieFilesAllFull({res(i,:).movfile});
          if ~tffound(i) % && ~isexternal,
            warning('Tracked movie [%s] does not correspond to any movie in the lbl file',...
              sprintf('%s ',res(i,:).movfile));
          end
        end
        
        for i = 1:nMovSets,
          if ~tffound(i),
            % conservative, take no action for now
            continue;
          end
          % we perform this check b/c while tracking has been running in
          % the bg, the project could have been updated, movies
          % renamed/reordered etc.
          
          % obj.trkSysInfo(i,:) has either
          % 1. nview els, each of which has a scalar cellstr .trkfileLcl;  OR
          % 2. 1 el, which has a [nview] cellstr .trkfileLcl
          trkfiles = [obj.trkSysInfo(i,:).trkfileLcl];
          trkfiles = trkfiles(:);
          obj.trkPostProcIfNec(mIdx(i),trkfiles);
          obj.trackResAddTrkfile(mIdx(i),trkfiles);
          if mIdx(i)==obj.lObj.currMovIdx
            obj.trackCurrResUpdate();
            obj.newLabelerFrame();
            if ~isexternal, % always true
              fprintf('Tracking complete for current movie at %s.\n',datestr(now));
            end
          else
            if ~isexternal, % always true
              iMov = mIdx.get();
              fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
            end
          end
        end
      end
      
      catch ME,
        warning('Error gathering tracking results:\n%s',getReport(ME));
      end
      
    end

    function trkCompleteCbkAWS(obj,backend,trkfilesLocal,res)
      fprintf('AWS: tracking complete at %s\n',datestr(now));
      assert(numel(trkfilesLocal)==numel(res));
 
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        
        aws = backend.awsec2;
        
        % download trkfiles 
        sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
        for ivw=1:numel(res)
          trkLcl = trkfilesLocal{ivw};
          trkRmt = res(ivw).trkfile;
          fprintf('Trying to download %s to %s...\n',trkRmt,trkLcl);
          aws.scpDownloadOrVerify(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs); % XXX doc orVerify
          fprintf('downloaded...\n');
        end
        
        obj.trkPostProcIfNec(mIdx,trkfilesLocal);
        obj.trackResAddTrkfile(mIdx,trkfilesLocal);
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
    end

    function trkPostProcIfNec(obj,mIdx,trkfiles,varargin) % obj const
      % When appropriate, perform postprocessing and re-save trkfiles in
      % place.
            
      [pp3dtype,calibrationfile,rois] = myparse(varargin,...
        'pp3dtype',obj.sPrmAll.ROOT.PostProcess.reconcile3dType, ...
        'calibrationfile','',...
        'cropROIs',[]...
        );
      
      isexternal = ~isnumeric(mIdx);
      
      do3dreconcile = ~strcmp(pp3dtype,'none');      
      nvw = obj.lObj.nview;
      %npts = obj.lObj.nPhysPoints;
      
      if do3dreconcile && nvw==2
        if ~isempty(calibrationfile) || (~obj.lObj.viewCalProjWide && isexternal),
          assert(~isempty(calibrationfile));
          vcd = CalRig.loadCreateCalRigObjFromFile(calibrationfile);
        else
          vcd = obj.lObj.getViewCalibrationDataMovIdx(mIdx);
        end
        if isempty(vcd),
          if isexternal,
            if iscell(mIdx),
              moviestr = mIdx{1};
            elseif ischar(mIdx),
              moviestr = mIdx;
            else
              moviestr = 'external movie';
            end
          else
            moviestr = obj.lObj.moviePrettyStr(mIdx);
          end
          warningNoTrace('Cannot perform 3D postprocessing; calibration data unset for %s.',moviestr);
          return;
        end
          
        assert(numel(trkfiles)==nvw);
        
        [trks,tfsucc] = ...
          cellfun(@(x)DeepTracker.hlpLoadTrk(x,'rawload',true),trkfiles,'uni',0);
        tfsucc = cell2mat(tfsucc);
        if ~all(tfsucc)
          ivwFailed = find(~tfsucc);
          ivwFailedStr = num2str(ivwFailed(:)');
          warningNoTrace('Cannot perform 3D postprocessing; could not load trkfiles for views: %s.',ivwFailedStr);
          return;
        end
        
        trk1 = trks{1};
        trk2 = trks{2};                
        if ~isexternal,
          rois = obj.lObj.getMovieRoiMovIdx(mIdx);
        end
        
        try
          [trk1save,trk2save] = PostProcess.triangulate(trk1,trk2,...
            rois,vcd,pp3dtype);
        catch ME
          warningNoTrace('3d postprocessing failed: %s',ME.getReport());
          return;
        end
        
        save(trkfiles{1},'-append','-struct','trk1save');
        fprintf(1,'Saved/appended variables ''pTrkSingleView'', ''pTrk'', ''pTrk3d'' to trkfile %s.\n',...
          trkfiles{1});
        save(trkfiles{2},'-append','-struct','trk2save');
        fprintf(1,'Saved/appended variables ''pTrkSingleView'', ''pTrk'', to trkfile %s.\n',...
          trkfiles{2});
      end
    end

    function trainStoppedCbk(obj,varargin)
      obj.trainCleanup();
      obj.notify('trainEnd');
    end
    
    function trackStoppedCbk(obj,varargin)
      obj.trackCleanup();
      obj.notify('trackEnd');
    end

    function trackCleanup(obj,varargin)
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
    
    function trainCleanup(obj,varargin)

      if obj.bgTrkIsRunning,
        fprintf('Stopping tracking...\n');
        obj.bgTrkMonitor.stop();
        obj.bgTrkMonitor.reset();
        assert(~obj.bgTrkIsRunning);
      end

      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      isCurr = obj.checkTrackingResultsCurrent();
      if ~isCurr,
        
        obj.cleanOutOfDateTrackingResults(isCurr);
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
        
        if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
          res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Delete');
          if strcmpi(res,'Retrack'),
            tblMFTRetrack = obj.getTrackedMFT();
            obj.track(tblMFTRetrack);
          end
        end

      end
      
      % completed/stopped training. old tracking results are deleted/updated, so trackerInfo should be updated
      obj.updateTrackerInfo();
      
      if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
        res = questdlg(sprintf('Training stopped after %d / %d iterations. Save trained model to file?',...
          obj.trackerInfo.iterCurr,obj.trackerInfo.iterFinal),'Save?','Save','Save as...','No','Save');
        if strcmpi(res,'Save'),
          obj.lObj.projSaveSmart();
          obj.lObj.projAssignProjNameFromProjFileIfAppropriate();
        elseif strcmpi(res,'Save as...'),
          obj.lObj.projSaveAs();
          obj.lObj.projAssignProjNameFromProjFileIfAppropriate();
        end
      end
    end
    
    function xvStoppedCbk(obj,varargin)
      
      % load xv res
      dmc = obj.trnSplitLastDMC;
      valresfiles = {dmc.valresultsLnx}';
      tfE = cellfun(@exist,valresfiles);
      if all(tfE)
        nsplt = numel(dmc);
        info = [];
        locs = [];
        preds = [];
        errs = [];
        splt = [];
        mdlfile = [];
        for isplt=1:nsplt          
          resfile = valresfiles{isplt};
          res = load(resfile,'-mat');
          fprintf(1,'Loaded results file %s\n',resfile);
                    
          assert(isequal(numel(res.info),size(res.locs,1),size(res.preds,1)));
          ni = numel(res.info);

          errl2 = sqrt(sum((res.locs-res.preds).^2,3)); % [n_splti x npt]

          info = cat(1,info,cat(1,res.info{:}));
          locs = cat(1,locs,reshape(res.locs,ni,[]));
          preds = cat(1,preds,reshape(res.preds,ni,[])); 
          errs = cat(1,errs,errl2);
          splt = cat(1,splt,isplt*ones(ni,1));
          mdlfile = cat(1,mdlfile,repmat({char(res.model_file)},ni,1));
        end
          
          
        tblXVres = table(info(:,1),info(:,2),info(:,3),...
          preds,locs,errs,splt,mdlfile,'VariableNames',...
          [MFTable.FLDSID {'p' 'pLbl' 'err' 'fold' 'modelfile'}]);
        obj.lObj.xvResults = tblXVres;
        obj.lObj.xvResultsTS = now;
        fprintf(1,'Set XV results on lObj.xvResults.*\n');

        obj.notify('trainEnd');
      end
    end
    
    function [trnstrs,modelFiles] = getTrkFileTrnStr(obj)
      % AL: odd method name
      
      obj.updateLastDMCsCurrInfo();
      
      trnstrs = cell(size(obj.trnLastDMC));
      modelFiles = cell(size(obj.trnLastDMC));
      for i = 1:numel(obj.trnLastDMC),
        trnstrs{i} = sprintf('trn%s_iter%d',obj.trnName,obj.trnLastDMC(i).iterCurr);
        modelFiles{i} = obj.trnLastDMC(i).trainCurrModelLnx;
        modelFiles{i} = regexprep(modelFiles{i},'\.index$','');
      end
    end
    
  end
  methods (Static) % train/track codegen
    function [tfsucc,res,warningstr] = syscmd(cmd,varargin)
      [tfsucc,res,warningstr] = AWSec2.syscmd(cmd,varargin{:},...
        'setenvcmd','LD_LIBRARY_PATH=: ');
    end
    function downloadPretrainedWeights(varargin) 
      aptroot = myparse(varargin,...
        'aptroot',APT.Root...
        );
      
      urlsAll = DeepTracker.pretrained_weights_urls;
      weightfilepats = DeepTracker.pretrained_weights_files_pat_lnx;
      deepnetrootlnx = [aptroot '/deepnet'];
      pretrainedlnx = [deepnetrootlnx '/pretrained'];
      for i = 1:numel(urlsAll)
        url = urlsAll{i};
        pat = weightfilepats{i};
        wfile = sprintf(pat,deepnetrootlnx);

        if exist(wfile,'file')>0
          fprintf('Tensorflow resnet pretrained weights %s already downloaded.\n',url);
          continue;
        end
          
        % hmm what happens when the weightfilenames change?
        fprintf('Downloading tensorflow resnet pretrained weights %s (APT)..\n',url);
        outfiles = untar(url,pretrainedlnx);
        sprintf('Downloaded and extracted the following files/directories:\n');
        fprintf('%s\n',outfiles{:});
      end      
    end
    function codestr = codeGenSSHGeneral(remotecmd,varargin)
      % Currently this assumes a JRC backend due to oncluster special case      
      [host,bg,prefix,sshoptions,timeout] = myparse(varargin,...
        'host',DLBackEndClass.jrchost,... % 'logfile','/dev/null',...
        'bg',false,... % AL 20201022 see note below
        'prefix',DLBackEndClass.jrcprefix,...
        'sshoptions','-o "StrictHostKeyChecking no"',...
        'timeout',[]);
      
      if ~isempty(prefix),
        remotecmd = [prefix,'; ',remotecmd];
      end
      if ~isempty(timeout),
        sshoptions1 = ['-o "ConnectTimeout ',num2str(timeout),'"'];
        if ~ischar(sshoptions) || isempty(sshoptions),
          sshoptions = sshoptions1;
        else
          sshoptions = [sshoptions,' ',sshoptions1];
        end
      end
          
      if ~ischar(sshoptions) || isempty(sshoptions),
        sshcmd = 'ssh';
      else
        sshcmd = ['ssh ',sshoptions];
      end
            
      if bg
        % AL 20201022 not sure why this codepath was nec. Now it is causing
        % problems with LSF/job scheduling. The </dev/null & business
        % confuses LSF and the account/runtime limit doesn't get set. So
        % for now this is a nonproduction codepath.
        codestr = sprintf('%s %s ''%s </dev/null &''',sshcmd,host,remotecmd);
      else
        tfOnCluster = ~isempty(getenv('LSB_DJOB_NUMPROC'));
        if tfOnCluster
          codestr = remotecmd;
        else
          codestr = sprintf('%s %s ''%s''',sshcmd,host,remotecmd);
        end
      end
    end
    function codestr = codeGenSingGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      DFLTBINDPATH = {
        '/groups/branson/bransonlab'
        '/groups/branson/home'
        '/nrs/branson'
        '/scratch'};      
      dobj = DLBackEndClass(1);
      [bindpath,singimg] = myparse(varargin,...
        'bindpath',DFLTBINDPATH,...
        'singimg','/groups/branson/bransonlab/apt/sif/prod.sif' ...
        );
        %'singimg',sprintf('docker://%s:%s', dobj.dockerimgroot ,dobj.dockerimgtag));
      delete(dobj);
      bindpath = cellfun(@(x)['"' x '"'],bindpath,'uni',0);      
      Bflags = [repmat({'-B'},1,numel(bindpath)); bindpath(:)'];
      Bflagsstr = sprintf('%s ',Bflags{:});
      codestr = sprintf('singularity exec --nv %s %s bash -c "%s"',...
        Bflagsstr,singimg,basecmd);
    end
    
    function plnx = codeGenPathUpdateWin2LnxContainer(pwin,mntloc)
      PAT1 = '^(?<drivelet>[a-zA-Z]):\\';
      REP1 = sprintf('%s/$<drivelet>/',mntloc);
      PAT2 = '^\\\\(?<server>[^/\\]+)[/\\]';
      REP2 = sprintf('%s/$<server>/',mntloc);
      PAT3 = '\\';
      REP3 = '/';
      plnx = regexprep(pwin,PAT1,REP1);
      plnx = regexprep(plnx,PAT2,REP2);
      plnx = regexprep(plnx,PAT3,REP3);
    end
    
    function codestr = codeGenCondaGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      [condaEnv,gpuid] = myparse(varargin,...
        'condaEnv','APT',...
        'gpuid',0);
      if ispc,
        envcmd = sprintf('set CUDA_DEVICE_ORDER=PCI_BUS_ID&& set CUDA_VISIBLE_DEVICES=%d',gpuid);
      else
        envcmd = sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID&& export CUDA_VISIBLE_DEVICES=%d',gpuid);
      end
      codestr = sprintf('activate %s&& %s&& %s',condaEnv,envcmd,basecmd);
    end
    function codestr = codeGenBsubGeneral(basecmd,varargin)
      [nslots,gpuqueue,outfile] = myparse(varargin,...
        'nslots',1,...
        'gpuqueue','gpu_any',...
        'outfile','/dev/null');
      codestr = sprintf('bsub -n %d -gpu "num=1" -q %s -o "%s" -R"affinity[core(1)]" %s',...
        nslots,gpuqueue,outfile,basecmd);      
    end
    function codestr = trainCodeGen(trnID,dllbl,cache,errfile,netType,...
        varargin)
      [view,deepnetroot,splitfile,classify_val,classify_val_out,...
        trainType,fs,filequote] = myparse(varargin,...
        'view',[],... % (opt) 1-based view index. If supplied, train only that view. If not, all views trained serially
        'deepnetroot',APT.getpathdl,...
        'split_file',[],...
        'classify_val',false,... % if true, split_file must be spec'd
        'classify_val_out',[],... % etc
        'trainType',DLTrainType.New,...
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths. 
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller 
                        ... % is expected to wrap in enclosing regular double-quotes " !!
          );
      tfview = ~isempty(view);
      
      aptintrf = [deepnetroot fs 'APT_interface.py'];
      
      switch trainType
        case DLTrainType.New
          continueflags = '';
        case DLTrainType.Restart
          continueflags = '-continue -skip_db';
        case DLTrainType.RestartAug
          continueflags = '-continue';
        otherwise
          assert(false);
      end
      
      dosplit = ~isempty(splitfile);
      if dosplit
        splitfileargs = sprintf('-split_file %s',[filequote splitfile filequote]);
        if classify_val
          splitfileargs = [splitfileargs sprintf(' -classify_val -classify_val_out %s',classify_val_out)];
        end
      else
        splitfileargs = '';
      end      
      
      codestr = sprintf('python %s -name %s',...
        [filequote aptintrf filequote],trnID);
      if tfview
        codestr = sprintf('%s -view %d',codestr,view); % APT_interface accepts 1-based view
      end      
      codestr = sprintf('%s -cache %s -err_file %s -type %s %s train -use_cache %s %s',...
        codestr,...
        [filequote cache filequote], ... % String.escapeSpaces(cache),...
        [filequote errfile filequote], ... % String.escapeSpaces(errfile),...
        netType,...
        [filequote dllbl filequote], ... % String.escapeSpaces(dllbl),...
        continueflags,...
        splitfileargs);
    end
    function [codestr,containerName] = trainCodeGenDocker(backend,...
        modelChainID,trainID,dllbl,cache,errfile,netType,trainType,...
        view1b,mntPaths,gpuid,varargin)
                  
      [dockerargs,isMultiView] = myparse(varargin,'dockerargs',{},'isMultiView',false);
      %baseargs = {'view' view1b};
      baseargs = {'trainType' trainType};
      if ~isMultiView,
        baseargs = [baseargs,{'view' view1b}];
      end

      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.trainCodeGen(modelChainID,dllbl,cache,errfile,...
        netType,baseargs{:},'filequote',filequote);

      if isempty(view1b),      
        containerName = [modelChainID '_' trainID];
      else
        containerName = [modelChainID '_' trainID '_view' num2str(view1b)];
      end
     
      codestr = backend.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,'gpuid',gpuid,dockerargs{:});      
    end
    function [codestr] = trainCodeGenConda(modelChainID,trainID,...
        dllbl,cache,errfile,netType,trainType,view1b,gpuid,varargin)
      
      [condaargs,isMultiView,outfile] = myparse(varargin,'condaargs',{},'isMultiView',false,...
        'outfile','');
      %fprintf(2,'TODO: restart/trainType\n');
      %baseargs = {'view' view1b};
      baseargs = {'trainType' trainType};
      if ~isMultiView,
        baseargs = [baseargs,{'view' view1b}];
      end
      
      basecmd = DeepTracker.trainCodeGen(modelChainID,dllbl,cache,errfile,...
        netType,baseargs{:},'filesep',filesep,'filequote','"');
      
      if ~isempty(outfile),
        basecmd = sprintf('%s > %s 2>&1',basecmd,outfile);
      end
      
      codestr = DeepTracker.codeGenCondaGeneral(basecmd,...
        'gpuid',gpuid,condaargs{:});
      
    end
    function [codestr,containerName] = trainCodeGenDockerDMC(dmc,backend,mntPaths,gpuid,varargin)
      [trnCmdType,leftovers] = myparse_nocheck(varargin,'trnCmdType',dmc.trainType);
      [codestr,containerName] = DeepTracker.trainCodeGenDocker(backend,...
        dmc.modelChainID,dmc.trainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,trnCmdType,dmc.view+1,mntPaths,gpuid,leftovers{:});
    end
    function [codestr] = trainCodeGenCondaDMC(dmc,gpuid,varargin)
      [trnCmdType,leftovers] = myparse_nocheck(varargin,'trnCmdType',dmc.trainType);
      [codestr] = DeepTracker.trainCodeGenConda(...
        dmc.modelChainID,dmc.trainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,trnCmdType,dmc.view+1,gpuid,...
        'outfile',dmc.trainLogLnx,leftovers{:});
    end
    function codestr = trainCodeGenSing(trnID,dllbl,cache,errfile,netType,...
        varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.trainCodeGen(trnID,dllbl,cache,errfile,...
        netType,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trainCodeGenBsubSing(trnID,dllbl,cache,errfile,...
        netType,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trainCodeGenSing(trnID,dllbl,cache,errfile,...
        netType,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end    
    function codestr = trainCodeGenSSHBsubSing(trnID,dllbl,cache,errfile,...
        netType,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{});
      remotecmd = DeepTracker.trainCodeGenBsubSing(trnID,dllbl,cache,...
        errfile,netType,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    function codestr = trainCodeGenSSHBsubSingDMC(aptroot,dmc,varargin)
      [singargs,bsubargs,trnCmdType] = myparse(varargin,...
        'singargs',{},...
        'bsubargs',{},...
        'trnCmdType',dmc.trainType...
        );
      
      if isempty(aptroot)
        aptroot = dmc.dirAptRootLnx;
      end
        
      repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
      repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,dmc.aptRepoSnapshotLnx);
      prefix = [DLBackEndClass.jrcprefix '; ' repoSScmd];      
      baseargs = {'view' dmc.view+1 'trainType' trnCmdType 'deepnetroot' [aptroot '/deepnet']};
      if dmc.doSplit
        baseargs(end+1:end+6) = {
          'split_file' 
          dmc.splitfileLnx
          'classify_val'
          true
          'classify_val_out'
          dmc.valresultsLnx
          };
      end
      codestr = DeepTracker.trainCodeGenSSHBsubSing(...
        dmc.modelChainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,...
        'baseArgs',baseargs,...
        'singargs',singargs,...
        'bsubArgs',[bsubargs {'outfile' dmc.trainLogLnx}],...
        'sshargs',{'prefix' prefix});
    end
        
    function downloadPretrainedExec(aptroot)
      % kb investigate: This doesn't work well on the cluster due to tf 
      % being a restricted site, plus /tmp acts weird
      assert(isunix,'Only supported on *nix platforms.');
      deepnetroot = [aptroot '/deepnet'];
      cmd = sprintf(DeepTracker.pretrained_download_script_py,deepnetroot);
      [~,res] = DeepTracker.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end      
    function codestr = updateAPTRepoCmd(varargin)
      [aptparent,downloadpretrained,branch] = myparse(varargin,...
        'aptparent','/home/ubuntu',...
        'downloadpretrained',false,...
        'branch','develop'... % branch to checkout
        );
      
      aptroot = [aptparent '/APT/deepnet'];
      
      codestr = {
        sprintf('cd %s;',aptroot);
        sprintf('git checkout %s;',branch);
        'git pull;'; 
        };
      if downloadpretrained
        % assumes we are on lnx. we cd-ed into deepnet above
        codestr{end+1,1} = sprintf(DeepTracker.pretrained_download_script_py,'.');
      end
      codestr = cat(2,codestr{:});
    end   
    function updateAPTRepoExecJRC(cacheRoot) % throws if fails
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      updatecmd = DeepTracker.updateAPTRepoCmd('aptparent',cacheRoot);
      updatecmd = DeepTracker.codeGenSSHGeneral(updatecmd,'bg',false);
      [~,res] = DeepTracker.syscmd(updatecmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = cpPTWfromJRCProdLnx(aptrootLnx)
      % copy cmd (lnx) deepnet/pretrained from production repo to JRC loc 
      srcPTWlnx = [DLBackEndClass.jrcprodrepo '/deepnet/pretrained'];
      dstPTWlnx = [aptrootLnx '/deepnet'];      
      cmd = sprintf('cp -r -u "%s" "%s"',srcPTWlnx,dstPTWlnx);
    end
    function cpupdatePTWfromJRCProdExec(aptrootLnx) % throws if errors
      cmd = DeepTracker.cpPTWfromJRCProdLnx(aptrootLnx);
      cmd = DeepTracker.codeGenSSHGeneral(cmd,'bg',false);
      [~,res] = DeepTracker.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = dirExistsCmd(ddir)
      cmd = sprintf('bash -c "[ -d ''%s'' ] && echo ''y'' || echo ''n''"',ddir);
    end      
    function cloneJRCRepoIfNec(cacheRoot) % throws on fail
      % Clone 'remote' repo into cacheRoot from prod, if necessary
      % 
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      
      % does repo in 'remote' cache exist?
      aptroot = [cacheRoot '/APT'];
      aptrootexistscmd = DeepTracker.dirExistsCmd(aptroot);
      aptrootexistscmd = DeepTracker.codeGenSSHGeneral(aptrootexistscmd,...
        'bg',false);
      
      [~,res] = DeepTracker.syscmd(aptrootexistscmd,...
        'dispcmd',true,...
        'failbehavior','err');
      res = strtrim(res);
      
      % clone it if nec
      switch res
        case 'y'
          fprintf('Found JRC/APT repo at %s.\n',aptroot);
        case 'n'
          cloneaptcmd = sprintf('git clone %s %s',DLBackEndClass.jrcprodrepo,aptroot);
          cloneaptcmd = DeepTracker.codeGenSSHGeneral(cloneaptcmd,'bg',false);
          [~,res] = DeepTracker.syscmd(cloneaptcmd,...
            'dispcmd',true,...
            'failbehavior','err');
          fprintf('Cloned JRC/APT repo into %s.\n',aptroot);
        otherwise
          error('Failed to update APT repo on JRC filesystem.');
      end
    end
          
    function codestr = trainCodeGenAWS(dmc,varargin)
      incViewFlag = myparse(varargin,...
        'incViewFlag',false... % if true, include -view flag to train a single view. if false, no -view flag specified, all views trained serially
        );
      
      assert(isscalar(dmc));
      
      trnCodeGenArgs = {
        dmc.modelChainID,dmc.lblStrippedLnx,dmc.rootDir, ...
        dmc.errfileLnx,char(dmc.netType),...
        'deepnetroot','/home/ubuntu/APT/deepnet',...
        'trainType',dmc.trainType};
      if incViewFlag
        trnCodeGenArgs = [trnCodeGenArgs {'view' dmc.view+1}];
      end
      
      codestr = {
        'cd /home/ubuntu/APT/deepnet;';
        'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
        DeepTracker.trainCodeGen(trnCodeGenArgs{:});
        };
      codestr = cat(2,codestr{:});
    end
    function str = cellstr2SpaceDelimWithEscapedSpace(c)
      % c: cellstr
      %
      % Use this to convert c to a space-delimited string for use as a
      % command-line argument. It is assumed this argument will be used in 
      % a *nix environment with eg python/argparse; individual elements of 
      % c will have any naked whitespaces escaped so that any such elements 
      % will not be (mis)interpretered as 2+ separate arguments.
      c = cellfun(@String.escapeSpaces,c,'uni',0);
      str = String.cellstr2DelimList(c,' ');
    end
    function str = cellstr2SpaceDelimWithQuote(c,quotechar)
      c = cellfun(@(x)[quotechar x quotechar],c,'uni',0);
      str = String.cellstr2DelimList(c,' '); 
    end
    function codestr = trackCodeGenBaseListFile(trnID,cache,dllbl,outfile,...
        errfile,nettype,view,listfile,varargin)
      % view: 1-based
      
      [deepnetroot,model_file,fs,filequote] = myparse_nocheck(varargin,...
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... 
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        );

      tfmodel = ~isempty(model_file);      
      aptintrf = [deepnetroot fs 'APT_interface.py'];

      code = { ...
        'python' [filequote aptintrf filequote] ...
        '-name' trnID ...
        '-view' num2str(view) ... % 1b 
        '-cache' [filequote cache filequote] ...
        '-err_file' [filequote errfile filequote] ...
        };
      if tfmodel
        code(end+1:end+2) = {'-model_files' [filequote model_file filequote]};
      end
      code = [code ...
        '-type' char(nettype) ...
        [filequote dllbl filequote] 'track' ...
        '-out' [filequote outfile filequote] ...
        '-list_file' [filequote listfile filequote] ];
      
      codestr = String.cellstr2DelimList(code,' ');
    end
    function codestr = trackCodeGenBaseGTClassify(trnID,cache,dllbl,gtoutfile,...
        errfile,nettype,varargin)
      % CodeGen for gtclassify; single view with single gtoutfile
      % 
      % Looks a lot like trackCodeGenBaseListFile
      
      [view,deepnetroot,model_file,fs,filequote] = myparse(varargin,...
        'view',[],... % 1b
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... 
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        );

      tfmodel = ~isempty(model_file);      
      aptintrf = [deepnetroot fs 'APT_interface.py'];

      code = { ...
        'python' [filequote aptintrf filequote] ...
        '-name' trnID ...
        };
      if ~isempty(view)
        code(end+1:end+2) = {'-view' num2str(view)}; ... % 1b 
      end
      code = [code ...
        { '-cache' [filequote cache filequote] ...
        '-err_file' [filequote errfile filequote] ...
        } ];
      if tfmodel
        code(end+1:end+2) = {'-model_files' [filequote model_file filequote]};
      end
      code = [code ...
        '-type' char(nettype) ...
        [filequote dllbl filequote] 'gt_classify' ...
        '-out' [filequote gtoutfile filequote] ];
      
      codestr = String.cellstr2DelimList(code,' ');
    end
    
    function codestr = trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,... % either char or [nviewx1] cellstr; or [nmov] in "serial mode" (see below)
        outtrk,... % either char of [nviewx1] cellstr; or [nmov] in "serial mode"
        frm0,frm1,... % (opt) can be empty. these should prob be in optional P-Vs
        varargin)
      
      % Serial mode: 
      % - movtrk is [nmov] array
      % - outtrk is [nmov] array
      % - trxtrk is unsupplied, or [nmov] array
      % - view is a *scalar* and *must be supplied*
      % - croproi is unsupplied, or [xlo1 xhi1 ylo1 yhi1 xlo2 ... yhi_nmov] or row vec of [4*nmov]
      % - model_file is unsupplied, or [1] cellstr, or [nmov] cellstr      
      
      [listfile,cache,trxtrk,trxids,view,croproi,hmaps,deepnetroot,model_file,log_file,...
        updateWinPaths2LnxContainer,lnxContainerMntLoc,fs,filequote,tfserialmode] = ...
        myparse_nocheck(varargin,...
        'listfile','',...
        'cache',[],... % (opt) cachedir
        'trxtrk','',... % (opt) trxfile for movtrk to be tracked 
        'trxids',[],... % (opt) 1-based index into trx structure in trxtrk. empty=>all trx
        'view',[],... % (opt) 1-based view index. If supplied, track only that view. If not, all views tracked serially 
        'croproi',[],... % (opt) 1-based [xlo xhi ylo yhi] roi (inclusive). can be [nview x 4] for multiview
        'hmaps',false,...% (opt) if true, generate heatmaps
        'deepnetroot',APT.getpathdl,...
        'model_file',[], ... % can be [nview] cellstr
        'log_file',[],... (opt)
        'updateWinPaths2LnxContainer',ispc, ... % if true, all paths will be massaged from win->lnx for use in container 
        'lnxContainerMntLoc','/mnt',... % used when updateWinPaths2LnxContainer==true
        'filesep','/',...
        'filequote','\"',... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        'serialmode', false ...  % see serialmode above
        );
     
      tflistfile = ~isempty(listfile);
      tffrm = ~tflistfile && ~isempty(frm0) && ~isempty(frm1);
      if tffrm, % ignore frm if it doesn't limit things
        if all(frm0 == 1) && all(isinf(frm1)),
          tffrm = false;
        end
      end
      tfcache = ~isempty(cache);
      tftrx = ~tflistfile && ~isempty(trxtrk);
      tftrxids = ~tflistfile && ~isempty(trxids);
      tfview = ~isempty(view);
      tfcrop = ~isempty(croproi) && ~all(any(isnan(croproi),2),1);
      tfmodel = ~isempty(model_file);
      tflog = ~isempty(log_file);
      
      movtrk = cellstr(movtrk);
      outtrk = cellstr(outtrk);
      if tftrx
        trxtrk = cellstr(trxtrk);
      end
      if tfmodel
        model_file = cellstr(model_file);
      end
      
      if tfserialmode
        nmovserialmode = numel(movtrk);
        assert(numel(outtrk)==nmovserialmode);
        if tftrx
          assert(numel(trxtrk)==nmovserialmode);
        end
        assert(isscalar(view),'A scalar view must be specified for serial-mode.');
        if tfcrop
          szassert(croproi,[nmovserialmode 4]);
        end
        if tfmodel
          if isscalar(model_file)
            model_file = repmat(model_file,nmovserialmode,1);
          else
            assert(numel(model_file)==nmovserialmode);
          end
        end        
      else
        if tfview % view specified. track a single movie
          nview = 1;
          assert(isscalar(view));
          if tftrx
            assert(isscalar(trxtrk));
          end
        else
          nview = numel(movtrk);
          if nview>1
            assert(~tftrx && ~tftrxids,'Trx not supported for multiple views.');
          end
        end
        assert(isequal(nview,numel(movtrk),numel(outtrk)));
        if tfmodel
          assert(numel(model_file)==nview);
        end
        if tfcrop
          szassert(croproi,[nview 4]);
        end      
      end
      
      assert(~(tftrx && tfcrop));
      aptintrf = [deepnetroot fs 'APT_interface.py'];
      
      if updateWinPaths2LnxContainer
        fcnPathUpdate = @(x)DeepTracker.codeGenPathUpdateWin2LnxContainer(x,lnxContainerMntLoc);
        aptintrf = fcnPathUpdate(aptintrf);

        movtrk = cellfun(fcnPathUpdate,movtrk,'uni',0);
        outtrk = cellfun(fcnPathUpdate,outtrk,'uni',0);
        if tftrx
          trxtrk = cellfun(fcnPathUpdate,trxtrk,'uni',0);
        end
        if tfmodel
          model_file = cellfun(fcnPathUpdate,model_file,'uni',0);
        end
        if tflog
          log_file = fcnPathUpdate(log_file);
        end
        if tfcache
          cache = fcnPathUpdate(cache);
        end
        errfile = fcnPathUpdate(errfile);
        dllbl = fcnPathUpdate(dllbl);
      end

      codestr = {'python' [filequote aptintrf filequote] '-name' trnID};
      if tfview
        codestr = [codestr {'-view' num2str(view)}]; % view: 1-based for APT_interface
      end
      if tfcache
        codestr = [codestr {'-cache' [filequote cache filequote]}];
      end
      codestr = [codestr {'-err_file' [filequote errfile filequote]}];
      if tfmodel
        codestr = [codestr {'-model_files' ...
                            DeepTracker.cellstr2SpaceDelimWithQuote(model_file,filequote)}];
      end
      if tflog
        codestr = [codestr {'-log_file' [filequote log_file filequote]}];
      end
      codestr = [codestr {'-type' char(nettype) ...
                          [filequote dllbl filequote] ...
                          'track' ...
                          '-out' DeepTracker.cellstr2SpaceDelimWithQuote(outtrk,filequote) }];
      if tflistfile
        codestr = [codestr {'-list_file' [filequote listfile filequote]}];
      else
        codestr = [codestr {'-mov' DeepTracker.cellstr2SpaceDelimWithQuote(movtrk,filequote)}];
      end
      if tffrm
        frm0(isnan(frm0)) = 1;
        frm1(isinf(frm1)|isnan(frm1)) = -1;
        frm0 = round(frm0); % fractional frm0/1 errs in APT_interface due to argparse type=int
        frm1 = round(frm1); % just round silently for now        
        sfrm0 = sprintf('%d ',frm0); sfrm0 = sfrm0(1:end-1);
        sfrm1 = sprintf('%d ',frm1); sfrm1 = sfrm1(1:end-1);
        codestr = [codestr {'-start_frame' sfrm0 '-end_frame' sfrm1}];
      end
      if tftrx
        codestr = [codestr {'-trx' DeepTracker.cellstr2SpaceDelimWithQuote(trxtrk,filequote)}];
        if tftrxids
          if ~iscell(trxids),
            trxids = {trxids};
          end
          for i = 1:numel(trxids),
            trxidstr = sprintf('%d ',trxids{i});
            trxidstr = trxidstr(1:end-1);
            codestr = [codestr {'-trx_ids' trxidstr}]; %#ok<AGROW>
          end
        end
      end
      if tfcrop
        croproi = round(croproi);
        croproirowvec = croproi';
        croproirowvec = croproirowvec(:)'; % [xlovw1 xhivw1 ylovw1 yhivw1 xlovw2 ...] OR [xlomov1 xhimov1 ylomov1 yhimov1 xlomov2 ...] in serialmode
        roistr = mat2str(croproirowvec);
        roistr = roistr(2:end-1);
        codestr = [codestr {'-crop_loc' roistr}];
      end
      if hmaps
        codestr = [codestr {'-hmaps'}];
      end
      
      codestr = String.cellstr2DelimList(codestr,' ');
    end
    
    function trackWriteListFile(movfileRem,movfileLcl,tMFTConc,listfileLcl,varargin)
      
      [trxfileRem,isWinBackend] = myparse(varargin,...
        'trxFiles',{},...
        'isWinBackend',false ...
        );
      
      nviews = size(movfileRem,2);
      ismultiview = nviews > 1;
      
      listinfo = struct;
      if ismultiview,
        listinfo.movieFiles = cell(size(movfileRem,1),1);
        for i = 1:size(movfileRem,1),
          listinfo.movieFiles{i} = movfileRem(i,:);
        end
        listinfo.trxFiles = cell(size(trxfileRem,1),1);
        for i = 1:size(trxfileRem,1),
          listinfo.trxFiles{i} = trxfileRem(i,:);
        end
      else
        listinfo.movieFiles = movfileRem;
        listinfo.trxFiles = trxfileRem;
      end

      % which movie index does each row correspond to?
      % assume first movie is unique
      [ism,idxm] = ismember(tMFTConc.mov(:,1),movfileLcl(:,1));
      assert(all(ism));
     
      listinfo.toTrack = cell(0,1);
      for mi = 1:size(movfileRem,1),
        idx1 = find(idxm==mi);
        if isempty(idx1),
          continue;
        end
        [t,~,idxt] = unique(tMFTConc.iTgt(idx1));
        for ti = 1:numel(t),
          idx2 = idxt==ti;
          idxcurr = idx1(idx2);
          f = unique(tMFTConc.frm(idxcurr));
          df = diff(f);
          istart = [1;find(df~=1)+1];
          iend = [istart(2:end)-1;numel(f)];
          for i = 1:numel(istart),
            if istart(i) == iend(i),
              fcurr = f(istart(i));
            else
              fcurr = [f(istart(i)),f(iend(i))+1];
            end
            listinfo.toTrack{end+1,1} = {mi,t(ti),fcurr};
          end
        end
      end

      if isWinBackend
        % AL20200929. json validity requires escaping backslash
        listinfo.movieFiles = regexprep(listinfo.movieFiles,'\\','\\\\');
        listinfo.trxFiles = regexprep(listinfo.trxFiles,'\\','\\\\');
      end
      fid = fopen(listfileLcl,'w');
      fprintf(fid,jsonencode(listinfo));
      fclose(fid);
      
    end
    
    function codestr = dataAugCodeGenSSHBsubSing(ID,dllbl,cache,errfile,netType,outfile,varargin)

      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{});
      remotecmd = DeepTracker.dataAugCodeGenBsubSing(ID,dllbl,cache,...
        errfile,netType,outfile,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    
    function codestr = dataAugCodeGenBsubSing(ID,dllbl,cache,errfile,netType,outfile,varargin)
    
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.dataAugCodeGenSing(ID,dllbl,cache,errfile,...
        netType,outfile,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
      
    end
    
    function codestr = dataAugCodeGenSing(ID,dllbl,cache,errfile,netType,outfile,...
        varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.dataAugCodeGenBase(ID,dllbl,cache,errfile,...
        netType,outfile,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    
    function [codestr] = dataAugCodeGenDocker(backend,...
        ID,dllbl,cache,errfile,netType,outfile,varargin)
      
      [baseargs,dockerargs,mntPaths] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{});
      
      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.dataAugCodeGenBase(ID,dllbl,cache,errfile,...
        netType,outfile,baseargs{:},'filequote',filequote);
      
      codestr = backend.codeGenDockerGeneral(basecmd,ID,...
        'bindpath',mntPaths,dockerargs{:});
    end    
    
    function codestr = dataAugCodeGenBase(ID,dllbl,cache,errfile,...
        nettype,outfile,varargin)
      
      [deepnetroot,model_file,fs,filequote] = myparse(varargin,...
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... % can be [nview] cellstr
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!        
        ); 
     
      tfcache = ~isempty(cache);
      tfmodel = ~isempty(model_file);
      
      if tfmodel
        model_file = cellstr(model_file);
      end

      aptintrf = [deepnetroot fs 'APT_interface.py'];      
    
      codestr = sprintf('python %s -name %s',...
        [filequote aptintrf filequote],ID);
      if tfcache
        %cache = String.escapeSpaces(cache);
        codestr = [codestr ' -cache ' [filequote cache filequote]];
      end
      %errfile = String.escapeSpaces(errfile);
      codestr = [codestr ' -err_file ' [filequote errfile filequote]];
      if tfmodel
        %modelfilestr = DeepTracker.cellstr2SpaceDelimWithEscapedSpace(model_file);
        codestr = sprintf('%s -model_files %s',codestr,...
          DeepTracker.cellstr2SpaceDelimWithQuote(model_file,filequote));
      end
      codestr = [codestr sprintf(' -type %s %s data_aug -out_file %s',...
        char(nettype),[filequote dllbl filequote],[filequote outfile filequote])];
    end    
    
    function [codestr,containerName] = trackCodeGenDocker(backend,...
        trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,dockerargs,mntPaths,containerName] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{},'containerName','');
      
      baseargs = [{'cache' cache} baseargs];
      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:},'filequote',filequote);

      if isempty(containerName),
        if iscell(outtrk),
          [~,containerName] = fileparts(outtrk{1});
        else
          [~,containerName] = fileparts(outtrk);
        end
      end
      
      codestr = backend.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,dockerargs{:});
    end
    
    function [codestr] = trackCodeGenConda(...
        trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)
%         movtrk,outtrk,frm0,frm1,...
%         modelChainID,trainID,dllbl,cache,errfile,netType,view1b,mntPaths,...
%         varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,condaargs,outfile] = myparse(varargin,...
        'baseargs',{},'condaargs',{},'outfile','');
      
      addnlbaseargs = {'cache' cache 'filequote' '"' 'updateWinPaths2LnxContainer' false};
      baseargs = [addnlbaseargs baseargs];
        
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:});
      if ~isempty(outfile),
        basecmd = sprintf('%s > %s 2>&1',basecmd,outfile);
      end
      codestr = DeepTracker.codeGenCondaGeneral(basecmd,...
        condaargs{:});
    end
    
    function codestr = trackCodeGenVenv(trnID,dllbl,movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,venvHost,venv,cudaVisDevice,logFile] = myparse(varargin,...
        'baseargs',{},... % p-v cell for trackCodeGenBase
        'venvHost','10.103.20.155',... % host to run DL verman-ws1
        'venv','/groups/branson/bransonlab/mayank/venv',... 
        'cudaVisDevice',[],... % if supplied, export CUDA_VISIBLE_DEVICES to this
        'logFile','/dev/null'...
      ); 
      
      basecode = DeepTracker.trackCodeGenBase(trnID,dllbl,movtrk,outtrk,...
        frm0,frm1,baseargs{:});
      if ~isempty(cudaVisDevice)
        cudaDeviceStr = ...
          sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID; export CUDA_VISIBLE_DEVICES=%d; ',...
          cudaVisDevice);
      else
        cudaDeviceStr = '';
      end
        
      codestrremote = sprintf('cd %s; source bin/activate; %s%s',venv,...
        cudaDeviceStr,basecode);
      codestr = DeepTracker.codeGenSSHGeneral(codestrremote,...
        'host',venvHost,'logfile',logFile);
    end
    function codestr = trackCodeGenSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trackCodeGenBsubSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trackCodeGenSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end
    
    function codestr = trackCodeGenSSHBsubSing(trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );
      baseargs = [baseargs {'cache' cache}];      
            
      remotecmd = DeepTracker.trackCodeGenBsubSing(trnID,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    
    function codestr = trackCodeGenListFileSSHBsubSing(trksysinfo,...
        trnID,nettype,view,varargin)
      
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );      
      
      cache = trksysinfo.dmcRootDir;
      dllbl = trksysinfo.lblStrippedLnx;
      errfile = trksysinfo.errfile;
      outfile = trksysinfo.outfile;
      listfile = trksysinfo.listfile;

      codebase = DeepTracker.trackCodeGenBaseListFile(trnID,cache,dllbl,...
        outfile,errfile,nettype,view,listfile,baseargs{:});
      codesing = DeepTracker.codeGenSingGeneral(codebase,singargs{:});
      codebsub = DeepTracker.codeGenBsubGeneral(codesing,bsubargs{:});
      codestr = DeepTracker.codeGenSSHGeneral(codebsub,sshargs{:});      
    end    
    function codestr = trackCodeGenAWS(...
        trnID,cacheRemote,dlLblRemote,errfileRemote,netType,movRemoteFull,...
        trkRemoteFull,frm0,frm1,baseargs)
      % movRemoteFull: can be cellstr when tracking all views
      % trkRemoteFull: "
      % 
      % baseargs: PV cell vector that goes to .trackCodeGenBase
      
      deepnetroot = '/home/ubuntu/APT/deepnet';
      baseargs = [baseargs {'cache' cacheRemote}];
      codestrbase = DeepTracker.trackCodeGenBase(trnID,dlLblRemote,...
        errfileRemote,netType,movRemoteFull,trkRemoteFull,frm0,frm1,...
        'deepnetroot',deepnetroot,baseargs{:});
      
      codestr = {
         'cd /home/ubuntu/APT/deepnet;';
         'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
         codestrbase
        };
      codestr = cat(2,codestr{:});
    end
    
    function [m,tfsuccess,isold] = parseTrkFileName(trkfile)
      
      tfsuccess = false;
      isold = false;
      [p,n,e] = fileparts(trkfile);
      m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>.*)_iter(?<iter>\d+)_(?<trk_ts>\d{8}T\d{6}).*$','names','once');
      if isempty(m),
        m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>.*)_(?<trk_ts>.*)$','names','once');
        if ~isempty(m),
          fprintf('trkfile %s does not have iteration name in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
            m.iter = iter(1);
            isold = true;
          catch ME,
            warning('Could not parse iteration from trkInfo.model_file');
            disp(getReport(ME));
            return;
          end
        else
          try
            tmp = load(trkfile,'trkInfo','expname','pTrkTS','-mat');
            m = struct;
            [~,m.base] = fileparts(tmp.expname);
            m.trn_ts = tmp.trkInfo.name;
            iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
            m.iter = iter(1);
            m.trk_ts = datestr(min(tmp.pTrkTS(:)),'yyyymmddTHHMMSS');
          catch ME,
            warning('Could not parse iteration from trkInfo.model_file');
            disp(getReport(ME));
            return;
          end
        end
      else
        m.iter = str2double(m.iter);
        isold = false;
      end
      m.path = p;
      m.ext = e;
      m.newName = fullfile(m.path,[m.base '_trn' m.trn_ts '_iter' num2str(m.iter) '_' m.trk_ts m.ext]);
      tfsuccess = true;
    end
    
    function [tfsucc,res] = waitForBsubComplete(jobid,cmd,nout,maxWaitTime,doKill)
      starttime = tic;
      res = cell(1,nout);
      bjobscmd = sprintf('bjobs %d',jobid);
      bjobscmd = DeepTracker.codeGenSSHGeneral(bjobscmd,'bg',false);
      killcmd = sprintf('bkill %d',jobid);
      killcmd = DeepTracker.codeGenSSHGeneral(killcmd,'bg',false);
      runStatuses = {'PEND','RUN','PROV','WAIT'};
      doneStatuses = {'DONE'};
      tfJobRunning = false;
      tfJobDone = false;
      
      while true,
        if toc(starttime) > maxWaitTime,
          break;
        end
        [tfsucc,res{:}] = cmd();
        %[augims,tfsucc] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
        if tfsucc,
          break;
        end
        tfJobRunning = false;
        [st2,res2] = system(bjobscmd);
        if st2 == 0,
          ss = strsplit(res2,'\n');
          ism = ~cellfun(@isempty,regexp(ss,'^JOBID','once'));
          i = find(ism,1);
          if ~isempty(i) && i < numel(ss),
            
            % make sure outout is formatted as I think it should be
            assert(~isempty(regexp(ss{i},'^\s*JOBID\s*USER\s*STAT','once')))
            res3 = ss{i+1};
            m = regexp(res3,'^(?<jobid>\d+)\s+(?<user>\w+)\s+(?<stat>\w+)','names','once');
            assert(~isempty(m));
            tfJobRunning = ismember(m.stat,runStatuses);
            tfJobDone = ismember(m.stat,doneStatuses);
            %fprintf('%fs: %s\n',toc(starttime),m.stat);
            
          end
        end
        if ~tfJobRunning && ~tfJobDone,
          warning('Could not find results. Output of bjobs:\n%s\n',res2);
          break;
        end
        drawnow;
      end
      if ~tfsucc && tfJobRunning && doKill,
        [st4,res4] = system(killcmd);
        if ~st4 == 0,
          error('Error killing:\n%s',res4);
        end
      end
      
    end


  end
  methods (Static) % train/track broker util
    function hdir = dlerrGetHomeDir
      m = getenvall;
      hdir = m('HOME');
    end
%     function errfile = dlGetTrackErrFile(trnID,hdir)
%       if exist('hdir','var')==0
%         hdir = DeepTracker.dlerrGetHomeDir;
%       end
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       errfileS = [trnID '_' nowstr '.err'];
%       errfile = fullfile(hdir,errfileS);
%     end
  end
  
  %% TrackRes = Tracking DB. all known tracking results on disk.  
  methods
    function trackResInit(obj)
      m = containers.Map('keytype','int32','valuetype','any');
      obj.movIdx2trkfile = m;
    end
    function trackResAddTrkfile(obj,mIdx,trkfiles)
      % Remember/add a set of [nview] trkfiles associated with mIdx
      
      assert(isscalar(mIdx));
      assert(iscellstr(trkfiles));
            
      [v,id] = obj.trackResGetTrkfiles(mIdx);      
      v(end+1,:) = trkfiles(:)';
      obj.movIdx2trkfile(id) = v;
    end
    function [trkfiles,id] = trackResGetTrkfiles(obj,mIdx)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        trkfiles = m(id);
      else
        trkfiles = cell(0,obj.lObj.nview);
      end      
    end
    function trackResSetTrkfiles(obj,mIdx,trkfiles)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        obj.movIdx2trkfile(id) = trkfiles;
      else
        obj.trackResAddTrkfile(mIdx,trkfiles)
      end      
    end
    function removeMissingTrkFiles(obj,mIdx)
      [trkfiles,id] = obj.trackResGetTrkfiles(mIdx);
      tfexists = cellfun(@(x) exist(x,'file'),trkfiles)>0;
      if ~all(tfexists),
        obj.movIdx2trkfile(id) = trkfiles(tfexists);
      end
    end
    function [tpos,taux,tauxlbl] = getTrackingResultsCurrMovie(obj)
      tpos = obj.trkP;
      taux = obj.trkAux;
      tauxlbl = obj.trkAuxLbl;
    end
    function [trkfileObjs,tfHasRes] = getTrackingResults(obj,mIdx)
      % Get tracking results for MovieIndices mIdx
      %
      % mIdx: [nMov] vector of MovieIndices
      %
      % trkfiles: [nMovxnView] cell of TrkFile objects, or [] if tfHasRes(...) is false
      % tfHasRes: [nMov] logical. If true, corresponding movie(set) has 
      %   tracking nontrivial (nonempty) tracking results
      %
      % DeepTracker uses the filesys as the tracking result DB. This loads 
      % from known/expected trkfiles.
            
      assert(isa(mIdx,'MovieIndex'));
      nMov = numel(mIdx);
      nView = obj.nview;
      trkfileObjs = cell(nMov,nView);
      tfHasRes = false(nMov,1);
      for i=1:nMov
        trkfilesI = obj.trackResGetTrkfiles(mIdx(i));
        movfile = obj.lObj.getMovieFilesAllFullMovIdx(mIdx(i));
        ntrk = size(trkfilesI,1);
        
        if ntrk==0
          % trkfileObjs, tfHasRes, trkfiles initted appropriately
          continue;
        end          
        if ntrk>1
          warningNoTrace('Merging tracking results from %d poseTF trkfiles.\n',ntrk);
        end        
        for ivw=1:nView
          [trkfilesIobj,tfsuccload] = cellfun(@(f) DeepTracker.hlpLoadTrk(f,'movfile',movfile{ivw}),...
            trkfilesI(:,ivw),'uni',0);
          tfsuccload = cell2mat(tfsuccload);
          trkfilesIobj = trkfilesIobj(tfsuccload);
          if isempty(trkfilesIobj)
            % if all loads failed
            % none; trkfiles, tfHasRes OK
          else
            tObj = trkfilesIobj{1};
            for iTmp=2:numel(trkfilesIobj)
              tObj.mergePartial(trkfilesIobj{iTmp});
            end
            trkfileObjs{i,ivw} = tObj;
            tfHasRes(i) = true;
          end
        end
      end
    end
    function isCurr = checkTrackingResultsCurrent(obj)
      
      isCurr = true;
      obj.updateLastDMCsCurrInfo();
      
      for moviei = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(moviei);
        % some trkfiles don't exist for some reason
        obj.removeMissingTrkFiles(mIdx);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if isempty(trkfiles),
          continue;
        end
        
        isFixed = false;
        newtrkfiles = trkfiles;
        for i = 1:size(trkfiles,1),
          for ivw = 1:size(trkfiles,2),
            [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfiles{i,ivw},ivw);
            assert(tfSuccess);
            if isOldFileName,
              isFixed = true;
              [tfSucc,msg] = copyfile(trkfiles{i,ivw},trkInfo.newName);
              if ~tfSucc,
                warning('Could not rename %s to %s: %s',trkfiles{i,ivw},newtrkfiles{i,ivw},msg);
              else
                newtrkfiles{i,ivw} = trkInfo.newName;
              end
            end
            if ~isCurr,
              %fprintf('Trkfile %s out of date, removing all tracking for movie %d\n',trkfiles{i},moviei);
              break;
            end
          end
        end
        if isFixed,
          obj.trackResSetTrkfiles(mIdx,newtrkfiles);
        end
        if ~isCurr,
          break;
        end

      end
      
    end
    
    function tblMFT = getTrackedMFT(obj,mIdxs)
      
      tblMFT = [];
      if nargin < 2,
        mIdxs = MovieIndex(1:obj.lObj.nmovies);
      end
      
      for mIdx = mIdxs(:)',
        [tblTrkRes] = obj.getAllTrackResTable(mIdx);
        if isempty(tblTrkRes),
          continue;
        end
        frm = tblTrkRes.frm;
        iTgt = tblTrkRes.iTgt;
        mov = repmat(mIdx,size(frm));
        tblMFT = [tblMFT;table(mov,frm,iTgt)]; %#ok<AGROW>

      end
      
    end
    
    function cleanOutOfDateTrackingResults(obj,isCurr)

      if nargin < 2,
        isCurr = obj.checkTrackingResultsCurrent();
      end
      if isCurr,
        return;
      end
      obj.trackResInit();
      obj.trackCurrResInit();
      % deleting old tracking results, so can switch to new tracker info
      obj.updateTrackerInfo();

%       for i = 1:numel(trkFilesToDelete),
%         delete(trkFilesToDelete{i});
%         if exist(trkFilesToDelete{i},'file'),
%           warning('Failed to delete trk file %s',trkFilesToDelete{i});
%         end
%       end
      
      
    end
    
    function [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfile,ivw)
      isCurr = true;
      [trkInfo,tfSuccess,isOldFileName] = DeepTracker.parseTrkFileName(trkfile);
      if ~tfSuccess,
        return;
      end
      isCurr = strcmp(obj.trnLastDMC(ivw).modelChainID,trkInfo.trn_ts) && ...
        (obj.trnLastDMC(ivw).iterCurr==trkInfo.iter);
    end
    
    function tf = isTrkFiles(obj)
    
      tf = false;
      for i = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(i);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if ~isempty(trkfiles),
          tf = true;
          return;
        end
      end
      
    end
    
  end
  methods (Static)
    function [trkfileObj,tfsuccload] = hlpLoadTrk(tfile,varargin)
      [rawload,movfile] = myparse(varargin,...
        'rawload',false,...
        'movfile',''...
        );
            
      try
        if rawload
          trkfileObj = load(tfile,'-mat');
        else
          trkfileObj = TrkFile.loadsilent(tfile,movfile);
        end
        tfsuccload = true;
      catch ME
        warningNoTrace('Failed to load trkfile: ''%s''. Error: %s',...
          tfile,ME.message);
        trkfileObj = [];
        tfsuccload  = false;
      end
    end
    
    
    function [tfsucc,augims] = loadAugmentedData(outfile,nview)

      tfsucc = false;
      augims = struct;
      for i = 1:nview,
        outfile_curr = sprintf('%s_%d.mat',outfile,i-1);
        if ~exist(outfile_curr,'file'),
          return;
        end
        da = load(outfile_curr);
        augims.ims{i} = permute(da.ims,[2,3,4,1]);
        augims.locs{i} = da.locs;
      end
      tfsucc = true;
    end
    
  end
  methods
    function [tblTrkRes,pTrkiPt] = getAllTrackResTable(obj,mIdxs) % obj const
      % Get all current tracking results in a table
      %
      % tblTrkRes: [NTrk x ncol] table of tracking results
      %            .pTrk, like obj.trkP; ABSOLUTE coords
      % pTrkiPt: [npttrk] indices into 1:obj.npts, tracked points. 
      %          size(tblTrkRes.pTrk,2)==npttrk*d

      m = obj.movIdx2trkfile;
      
      if m.isempty
        tblTrkRes = [];
        pTrkiPt = [];
        return;
      end
      
      if nargin < 2,
        mIdxs = m.keys;
        mIdxs = cell2mat(mIdxs(:));
      end
      if ~isa(mIdxs,'MovieIndex'),
        mIdxs = MovieIndex(mIdxs);
      end
      [trk,tfhasres] = obj.getTrackingResults(mIdxs);

      tblTrkRes = [];
      pTrkiPt = -1;
      for i=1:numel(mIdxs)
        if tfhasres(i)
          if isequal(pTrkiPt,-1)
            pTrkiPt = trk{i,1}.pTrkiPt;
          end
          if ~isequal(pTrkiPt,trk{i,1}.pTrkiPt)
            error('Trkfiles differ in tracked points .pTrkiPt.');
          end
          tbl = trk{i,1}.tableform;
          tblmov = table(repmat(mIdxs(i),height(tbl),1),'VariableNames',{'mov'});
          tbl = [tblmov tbl];
          tblTrkRes = [tblTrkRes;tbl]; %#ok<AGROW>
        end         
      end
    end
    function clearTrackingResults(obj)
      % FUTURE TODO: For now we do not actually delete the previous trkfiles.
      obj.trackResInit();
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  
  %% TrackCurrRes = tracked state for current movie. Loaded into .trkP*
  methods
    function trackCurrResInit(obj)
      % Assumes that .trnNetType is set
      obj.trkP = [];
      obj.trkPTS = zeros(0,1);
      obj.trkAux = [];
      obj.trkAuxLbl = {obj.trnNetType.trkAuxFlds.label}';
    end
    function trackCurrResUpdate(obj)
      % update trackCurrRes (.trkP*) from trackRes (tracking DB)
      mIdx = obj.lObj.currMovIdx;
      if isempty(mIdx) || mIdx==0 || obj.lObj.isinit
        % proj load etc
        return;
      end
      [trks,tfHasRes] = obj.getTrackingResults(mIdx);
      if tfHasRes
        obj.trackCurrResLoadFromTrks(trks);
        
%         tfTrx = obj.lObj.hasTrx;
%         
%         trkfilesCurr = obj.trackResGetTrkfiles(mIdx); % [ntrk x nview]
%         ntrkCurr = size(trkfilesCurr,1);
%         for ivw=1:1 % TODO: multiview
%           for itrk=1:ntrkCurr
%             trkfile = trkfilesCurr{itrk,ivw};
%             [trkfileP,trkfileF] = fileparts(trkfile);
%             hmapDirS = [trkfileF '_hmap'];
%             hmapDir = fullfile(trkfileP,hmapDirS);
%             if exist(hmapDir,'dir')>0
%               if tfTrx
%                 % Ideally the heatmaps size is related to 
%                 % sPrm....TargetCrop.Radius, but they might not have set
%                 % that, etc etc
%                 hmnr = [];
%                 hmnc = [];
%               else
%                 hmnr = obj.lObj.movienr;
%                 hmnc = obj.lObj.movienc;
%               end
%               obj.trkVizer.heatMapInit(hmapDir,hmnr,hmnc);
%               if ntrkCurr==1
%                 fprintf('Found heatmap dir: %s\n',hmapDirS);
%               else                
%                 fprintf('Found heatmap dir %s for trkfile %d/%d. Other heatmap dirs (if any) will be ignored.\n',...
%                   hmapDirS,itrk,ntrkCurr);
%               end
%               break;
%             end
%           end
%         end
      else
        obj.trackCurrResInit();
      end
      notify(obj,'newTrackingResults');
    end
    function trackCurrResLoadFromTrks(obj,trks)
      % trks: [nview] cell of TrkFile objs
      
      assert(numel(trks)==obj.nview);
      
      lObj = obj.lObj;
      ipt2view = lObj.labeledposIPt2View;
      
      npt = obj.nPts;
      nfrm = lObj.nframes;
      ntgt = lObj.nTargets;
      auxInfo = obj.trnNetType.trkAuxFlds;
      naux = numel(auxInfo);
      
      pTrk = nan(npt,2,nfrm,ntgt);
      pTrkTS = nan(npt,nfrm,ntgt); 
      aux = nan(npt,nfrm,ntgt,naux);
      
      for iview=1:obj.nview
        t = trks{iview};
        frms = t.pTrkFrm;
        itgts = t.pTrkiTgt;
        ipts = ipt2view==iview;
        pTrk(ipts,:,frms,itgts) = t.pTrk;
        pTrkTS(ipts,frms,itgts) = t.pTrkTS;
        
        for iaux=1:naux
          trkfld = auxInfo(iaux).trkfld;
          if isprop(t,trkfld)
            aux(ipts,frms,itgts,iaux) = t.(trkfld);
          else
            % aux els remain nan
            % Don't warn as not all auxflds must be there. eg pTrkocc is
            % only present if params request it etc.
            % warningNoTrace('Missing field ''%s'' in trkfile.',trkfld);
          end
        end
      end
            
      obj.trkP = pTrk;
      obj.trkPTS = pTrkTS;
      obj.trkAux = aux;
      %obj.trkAuxLbl = {auxInfo.label}';
    end
    function [xy,tfocc] = getPredictionCurrentFrame(obj)
      % xy: [nPtsx2xnTgt], tracking results for all targets in current frm
      % tfocc: [nPtsxnTgt] logical
      
      frm = obj.lObj.currFrame;
      xyPCM = obj.trkP;
      
      if isempty(xyPCM)
        npts = obj.nPts;
        nTgt = obj.lObj.nTargets;
        xy = nan(npts,2,nTgt);
        tfocc = false(npts,nTgt);
      else
        % AL20160502: When changing movies, order of updates to 
        % lObj.currMovie and lObj.currFrame is unspecified. currMovie can
        % be updated first, resulting in an OOB currFrame; protect against
        % this.
        frm = min(frm,size(xyPCM,3));
        xy = squeeze(xyPCM(:,:,frm,:)); % [npt x d x ntgt]
        
        if nargout>1
          tfscrocc = strcmp(obj.trkAuxLbl,'scr_occ');
          switch nnz(tfscrocc)
            case 0
              scrocc = nan(obj.nPts,obj.lObj.nTargets);
            case 1
              scrocc = squeeze(obj.trkAux(:,frm,:,tfscrocc));
            otherwise
              assert(false,'Multiple fields matching ''scr_occ''.');              
          end
          tfocc = scrocc > DeepTracker.MDN_OCCLUDED_THRESH;              
        end
      end
    end
  end
    
  %% Viz
  methods
    function vizInit(obj)
      obj.trkVizer.vizInit();
      obj.setHideViz(obj.hideViz);
    end
    function setHideViz(obj,tf)
      obj.trkVizer.setHideViz(tf);
      obj.hideViz = tf;
    end
    function setShowPredsCurrTargetOnly(obj,tf)
      obj.trkVizer.setShowOnlyPrimary(tf);
      obj.showPredsCurrTargetOnly = tf;
    end
    function updateLandmarkColors(obj)
      ptsClrs = obj.lObj.predPointsPlotInfo.Colors;
      ptsClrs = obj.lObj.Set2PointColors(ptsClrs);
      obj.trkVizer.updateLandmarkColors(ptsClrs);      
    end
    % For updating other cosmetics, go ahead and call obj.trkVizer methods
    % directly
  end

  %% Labeler nav
  methods
    function newLabelerFrame(obj)
      lObj = obj.lObj;
      if lObj.isinit || ~lObj.hasMovie
        return;
      end
            
      [xy,tfocc] = obj.getPredictionCurrentFrame();    
%       frm = lObj.currFrame;
%       itgt = lObj.currTarget;
%       trx = lObj.currTrx;
%       if isempty(trx)
%         trxXY = [];
%         trxTh = [];        
%       else
%         itrx = frm+trx.off;
%         if itrx <= 0 || itrx > numel(trx.x),
%           return;
%         end
%         trxXY = [trx.x(itrx) trx.y(itrx)];
%         trxTh = trx.theta(itrx);        
%       end        
      obj.trkVizer.updateTrackRes(xy,tfocc);
    end
    function newLabelerTarget(obj)
      return;
      iTgt = obj.lObj.currTarget;
      obj.trkVizer.updatePrimary(iTgt);
    end
    function newLabelerMovie(obj)
      obj.vizInit(); % not sure why this is nec
      if obj.lObj.hasMovie
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end
    end
  end
  
  %% Labeler listeners
  methods
    function labelerMovieRemoved(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      tfLabeledTrainingRowRemoved = ~isempty(edata.mIdxRmedHadLbls) && ...
                                    edata.mIdxRmedHadLbls>0; % negative indices indicate GT movie(s)
      if tfLabeledTrainingRowRemoved
        warningNoTrace('Labeled row(s) removed from project. Clearing trained tracker and tracking results.');
        obj.initHook();
      else
        % relabel movie indices
        obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
        
        % skip this stuff; current movie can never be removed so preds for
        % current movie should not change
        %obj.trackCurrResUpdate();
        %obj.newLabelerFrame();
      end      
    end
    function labelerMoviesReordered(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
      
      % Assume trackCurrRes does not need update
    end
  end  
  
end